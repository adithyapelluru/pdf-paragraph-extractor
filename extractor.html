<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Paragraph Extractor</title>
  <style>
    :root {
      --bg-gradient-start: #667eea;
      --bg-gradient-end: #764ba2;
      --container-bg: white;
      --text-color: #333;
      --text-secondary: #666;
      --border-color: #ddd;
      --section-bg: #f8f9ff;
      --section-hover: #f0f2ff;
      --section-active: #e8ebff;
      --notes-bg: white;
      --notes-border: #667eea;
      --shadow-color: rgba(0,0,0,0.3);
    }
    
    [data-theme="dark"] {
      --bg-gradient-start: #000000;
      --bg-gradient-end: #000000;
      --container-bg: #000000;
      --text-color: #e0e0e0;
      --text-secondary: #b0b0b0;
      --border-color: #1a1a1a;
      --section-bg: #000000;
      --section-hover: #0a0a0a;
      --section-active: #151515;
      --notes-bg: #000000;
      --notes-border: #1a1a1a;
      --shadow-color: rgba(0,0,0,0.9);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      transition: background 0.3s ease;
    }
    
    .container {
      background: var(--container-bg);
      border-radius: 20px;
      box-shadow: 0 20px 60px var(--shadow-color);
      max-width: 1200px;
      width: 100%;
      overflow: hidden;
      transition: background 0.3s ease;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
      transition: background 0.3s ease;
    }
    
    [data-theme="dark"] .header {
      background: #000000;
      border-bottom: 2px solid #1a1a1a;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    .header p {
      opacity: 0.9;
      font-size: 16px;
    }
    
    .upload-section {
      padding: 40px;
      text-align: center;
    }
    
    .upload-box {
      border: 3px dashed #667eea;
      border-radius: 15px;
      padding: 60px 40px;
      background: var(--section-bg);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-box:hover {
      background: var(--section-hover);
      border-color: #764ba2;
    }
    
    .upload-box.dragover {
      background: var(--section-active);
      border-color: #764ba2;
      transform: scale(1.02);
    }
    
    .upload-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    
    .upload-text {
      font-size: 20px;
      color: var(--text-color);
      margin-bottom: 10px;
    }
    
    .upload-hint {
      color: var(--text-secondary);
      font-size: 14px;
    }
    
    .file-input {
      display: none;
    }
    
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    [data-theme="dark"] .btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    [data-theme="dark"] .btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .results {
      padding: 40px;
      display: none;
    }
    
    .results.show {
      display: block;
    }
    
    .file-info {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--section-bg);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      color: var(--text-color);
      transition: background 0.3s ease;
    }
    
    .file-info-text {
      flex: 0 0 auto;
    }
    
    .file-info-actions {
      flex: 1;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    
    .page-section {
      margin-bottom: 30px;
      background: var(--section-bg);
      padding: 20px;
      border-radius: 15px;
      transition: background 0.3s ease;
    }
    
    .page-header {
      font-size: 20px;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .paragraphs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }
    
    .paragraph-item {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    [data-theme="dark"] .paragraph-item {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .paragraph-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }
    
    .paragraph-item.selected {
      background: #FF9800;
    }
    
    [data-theme="dark"] .paragraph-item.selected {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .paragraph-item.copied {
      background: #4CAF50;
    }
    
    [data-theme="dark"] .paragraph-item.copied {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .para-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    
    .paragraph-item label {
      cursor: pointer;
      user-select: none;
    }
    
    .page-actions {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: flex-start;
    }
    
    .page-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    [data-theme="dark"] .page-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .page-btn:hover {
      background: #764ba2;
    }
    
    [data-theme="dark"] .page-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .page-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    [data-theme="dark"] .page-btn:disabled {
      background: #000000;
      border-color: #1a1a1a;
      color: #666;
    }
    
    .page-notes {
      margin-top: 15px;
      padding: 15px;
      background: var(--notes-bg);
      border-radius: 10px;
      border: 2px solid var(--notes-border);
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    
    .notes-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .notes-title {
      font-weight: bold;
      color: #667eea;
      font-size: 16px;
    }
    
    .notes-textarea {
      width: 100%;
      min-height: 80px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      transition: border-color 0.3s;
      display: none;
      background: var(--notes-bg);
      color: var(--text-color);
    }
    
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .notes-display {
      width: 100%;
      min-height: 80px;
      height: 120px;
      max-height: 400px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: var(--section-bg);
      overflow-y: auto;
      scroll-behavior: smooth;
      resize: vertical;
      cursor: default;
      user-select: text;
      color: var(--text-color);
      transition: background 0.3s ease, color 0.3s ease;
    }
    

    
    .notes-display:empty:before {
      content: attr(data-placeholder);
      color: #999;
    }
    
    /* Definition Popup */
    .definition-popup {
      position: absolute;
      background: var(--container-bg);
      border: 2px solid #667eea;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 5px 20px var(--shadow-color);
      z-index: 10002;
      max-width: 350px;
      min-width: 250px;
      display: none;
      animation: popupFadeIn 0.2s ease;
      color: var(--text-color);
      transition: background 0.3s ease;
    }
    
    .definition-popup.show {
      display: block;
    }
    
    @keyframes popupFadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .definition-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 2px solid #667eea;
    }
    
    .definition-word {
      font-size: 18px;
      font-weight: bold;
      color: #667eea;
    }
    
    .definition-close {
      background: #f44336;
      color: white;
      border: none;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }
    
    .definition-close:hover {
      background: #d32f2f;
      transform: rotate(90deg);
    }
    
    .definition-content {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .definition-loading {
      text-align: center;
      padding: 20px;
      color: #667eea;
    }
    
    .definition-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    
    .definition-error {
      color: #f44336;
      padding: 10px;
      text-align: center;
    }
    
    .definition-meaning {
      margin-bottom: 15px;
    }
    
    .definition-pos {
      font-style: italic;
      color: #764ba2;
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    .definition-text {
      color: var(--text-color);
      line-height: 1.6;
      margin-bottom: 5px;
    }
    
    .definition-example {
      color: var(--text-secondary);
      font-style: italic;
      font-size: 13px;
      padding-left: 15px;
      border-left: 3px solid #667eea;
      margin-top: 5px;
    }
    

    
    .definition-phonetic {
      color: #666;
      font-size: 14px;
      margin-bottom: 10px;
      transition: all 0.3s;
    }
    
    .definition-phonetic[style*="cursor: pointer"] {
      color: #667eea;
      font-weight: bold;
    }
    
    .definition-phonetic[style*="cursor: pointer"]:hover {
      color: #764ba2;
      transform: scale(1.05);
    }
    
    .definition-phonetic[style*="cursor: pointer"]:active {
      transform: scale(0.95);
    }
    
    /* Double-tap feedback animation */
    @keyframes tap-feedback {
      0% {
        background: rgba(102, 126, 234, 0.2);
      }
      100% {
        background: transparent;
      }
    }
    
    .tap-feedback {
      animation: tap-feedback 0.3s ease;
    }
    
    .notes-resize-handle {
      display: none;
      width: 100%;
      height: 30px;
      background: var(--section-hover);
      border-top: 2px solid #667eea;
      border-radius: 0 0 8px 8px;
      cursor: ns-resize;
      text-align: center;
      line-height: 30px;
      color: #667eea;
      font-size: 12px;
      user-select: none;
      touch-action: none;
      transition: background 0.3s ease;
    }
    
    .notes-resize-handle:hover {
      background: var(--section-active);
    }
    
    .notes-resize-handle:active {
      background: var(--section-active);
    }
    
    .highlight-word {
      background: #FFD700;
      color: #000;
      padding: 2px 0;
      border-radius: 3px;
      animation: highlight-pulse 0.3s ease;
    }
    
    @keyframes highlight-pulse {
      0% { background: #FFD700; }
      50% { background: #FFA500; }
      100% { background: #FFD700; }
    }
    
    .notes-saved {
      color: #4CAF50;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .notes-saved.show {
      opacity: 1;
    }
    
    .notes-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .notes-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }
    
    [data-theme="dark"] .notes-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .notes-btn:hover {
      background: #764ba2;
      transform: translateY(-1px);
    }
    
    [data-theme="dark"] .notes-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    [data-theme="dark"] .notes-btn:disabled {
      background: #000000;
      border-color: #1a1a1a;
      color: #666;
    }
    
    .notes-btn.speaking {
      background: #FF9800;
      animation: pulse 1.5s infinite;
    }
    
    [data-theme="dark"] .notes-btn.speaking {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.paused {
      background: #FFA726;
    }
    
    [data-theme="dark"] .notes-btn.paused {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.stop {
      background: #f44336;
    }
    
    [data-theme="dark"] .notes-btn.stop {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.stop:hover {
      background: #d32f2f;
    }
    
    [data-theme="dark"] .notes-btn.stop:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.font-control {
      background: #9C27B0;
      min-width: 32px;
      padding: 6px 8px;
    }
    
    [data-theme="dark"] .notes-btn.font-control {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.font-control:hover {
      background: #7B1FA2;
    }
    
    [data-theme="dark"] .notes-btn.font-control:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.fullscreen {
      background: #00BCD4;
    }
    
    [data-theme="dark"] .notes-btn.fullscreen {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.fullscreen:hover {
      background: #0097A7;
    }
    
    [data-theme="dark"] .notes-btn.fullscreen:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.edit-toggle {
      background: #f44336;
    }
    
    [data-theme="dark"] .notes-btn.edit-toggle {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.edit-toggle:hover {
      background: #d32f2f;
    }
    
    [data-theme="dark"] .notes-btn.edit-toggle:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.edit-toggle.unlocked {
      background: #4CAF50;
    }
    
    [data-theme="dark"] .notes-btn.edit-toggle.unlocked {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.edit-toggle.unlocked:hover {
      background: #45a049;
    }
    
    [data-theme="dark"] .notes-btn.edit-toggle.unlocked:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.rewind {
      background: #FF5722;
      min-width: 32px;
      padding: 6px 8px;
    }
    
    [data-theme="dark"] .notes-btn.rewind {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.rewind:hover {
      background: #E64A19;
    }
    
    [data-theme="dark"] .notes-btn.rewind:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn.forward {
      background: #FF5722;
      min-width: 32px;
      padding: 6px 8px;
    }
    
    [data-theme="dark"] .notes-btn.forward {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .notes-btn.forward:hover {
      background: #E64A19;
    }
    
    [data-theme="dark"] .notes-btn.forward:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Fullscreen modal */
    .notes-fullscreen-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      padding: 20px;
      overflow: auto;
    }
    
    .notes-fullscreen-modal.show {
      display: flex;
      flex-direction: column;
    }
    
    .fullscreen-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px 10px 0 0;
      color: white;
      flex-shrink: 0;
      transition: background 0.3s ease;
    }
    
    [data-theme="dark"] .fullscreen-header {
      background: #000000;
      border-bottom: 2px solid #1a1a1a;
    }
    
    .fullscreen-title {
      font-size: 20px;
      font-weight: bold;
    }
    
    .fullscreen-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }
    
    .fullscreen-close:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(90deg);
    }
    
    .fullscreen-content {
      flex: 1;
      background: var(--container-bg);
      padding: 30px;
      border-radius: 0 0 10px 10px;
      overflow: auto;
      min-height: 0;
      transition: background 0.3s ease;
    }
    
    .fullscreen-notes {
      width: 100%;
      min-height: 100%;
      padding: 20px;
      border: 2px solid #667eea;
      border-radius: 10px;
      font-family: inherit;
      font-size: 18px;
      line-height: 1.8;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: var(--section-bg);
      outline: none;
      resize: none;
      cursor: default;
      user-select: text;
      color: var(--text-color);
      transition: background 0.3s ease, color 0.3s ease;
    }
    
    .fullscreen-notes:empty:before {
      content: attr(data-placeholder);
      color: #999;
    }
    
    @media (max-width: 768px) {
      .notes-fullscreen-modal {
        padding: 0;
      }
      
      .fullscreen-header {
        border-radius: 0;
        padding: 12px 15px;
      }
      
      .fullscreen-title {
        font-size: 16px;
      }
      
      .fullscreen-close {
        width: 35px;
        height: 35px;
        font-size: 20px;
      }
      
      .fullscreen-content {
        padding: 15px;
        border-radius: 0;
      }
      
      .fullscreen-notes {
        font-size: 16px;
        padding: 15px;
      }
    }
    
    .font-size-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    
    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: var(--section-hover);
      border-radius: 8px;
      transition: background 0.3s ease;
    }
    
    .speed-label {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 80px;
    }
    
    .speed-slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }
    
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .speed-slider::-webkit-slider-thumb:hover {
      background: #764ba2;
    }
    
    .speed-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
      transition: background 0.3s;
    }
    
    .speed-slider::-moz-range-thumb:hover {
      background: #764ba2;
    }
    
    .speed-value {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 35px;
      text-align: right;
    }
    
    .floating-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: #4CAF50;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
      transition: all 0.3s;
      z-index: 1000;
    }
    
    [data-theme="dark"] .floating-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .floating-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.5);
    }
    
    [data-theme="dark"] .floating-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .scroll-top-btn {
      position: fixed;
      bottom: 100px;
      right: 30px;
      background: #667eea;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: none;
    }
    
    [data-theme="dark"] .scroll-top-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .scroll-top-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      background: #764ba2;
    }
    
    [data-theme="dark"] .scroll-top-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .scroll-top-btn.show {
      display: block;
    }
    
    .last-copied-btn {
      position: fixed;
      bottom: 165px;
      right: 30px;
      background: #FF9800;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(255, 152, 0, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: none;
    }
    
    [data-theme="dark"] .last-copied-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .last-copied-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(255, 152, 0, 0.5);
      background: #F57C00;
    }
    
    [data-theme="dark"] .last-copied-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .last-copied-btn.show {
      display: block;
    }
    
    .back-floating-btn {
      position: fixed;
      top: 30px;
      left: 30px;
      background: #666;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    [data-theme="dark"] .back-floating-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .back-floating-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      background: #555;
    }
    
    [data-theme="dark"] .back-floating-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .theme-toggle-btn {
      position: fixed;
      top: 30px;
      left: 90px;
      background: #667eea;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .theme-toggle-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      background: #764ba2;
    }
    
    .back-btn {
      background: #666;
      margin-right: 10px;
    }
    
    .search-box {
      display: flex;
      gap: 8px;
      align-items: center;
      flex: 1;
      max-width: 400px;
    }
    
    .search-input {
      flex: 1;
      padding: 10px 15px;
      border: 2px solid #667eea;
      border-radius: 20px;
      font-size: 14px;
      font-family: inherit;
      outline: none;
      transition: all 0.3s;
      min-width: 200px;
      background: var(--notes-bg);
      color: var(--text-color);
    }
    
    .search-input:focus {
      border-color: #764ba2;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
    }
    
    .search-clear-btn {
      background: #f44336;
      color: white;
      border: none;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      flex-shrink: 0;
    }
    
    .search-clear-btn:hover {
      background: #d32f2f;
      transform: rotate(90deg);
    }
    
    .search-loading {
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
      flex-shrink: 0;
    }
    
    .search-loading.show {
      display: block;
    }
    
    .search-results {
      display: none;
      padding: 15px;
      background: var(--notes-bg);
      border-radius: 10px;
      border: 2px solid #4CAF50;
      margin-bottom: 20px;
      transition: background 0.3s ease;
    }
    
    .search-results.show {
      display: block;
    }
    
    .search-results-title {
      font-weight: bold;
      color: #4CAF50;
      margin-bottom: 10px;
      font-size: 16px;
    }
    
    .search-matches {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .search-match-item {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 14px;
      font-weight: bold;
    }
    
    .search-match-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
    }
    
    .search-no-results {
      color: #f44336;
      font-style: italic;
    }
    
    .paragraph-item.search-highlight {
      animation: search-pulse 1s ease-in-out;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }
    
    @keyframes search-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      display: none;
    }
    
    .loading.show {
      display: block;
    }
    
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    @keyframes slideDown {
      from {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      to {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .definition-popup {
        max-width: calc(100vw - 40px);
        min-width: 250px;
        left: 20px !important;
        right: 20px;
      }
      
      .definition-word {
        font-size: 16px;
      }
      
      .definition-content {
        max-height: 300px;
      }
      

      
      body {
        padding: 10px;
      }
      
      .header h1 {
        font-size: 24px;
      }
      
      .header p {
        font-size: 14px;
      }
      
      .upload-section, .results {
        padding: 20px;
      }
      
      .upload-box {
        padding: 30px 20px;
      }
      
      .upload-icon {
        font-size: 48px;
      }
      
      .upload-text {
        font-size: 18px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      .file-info {
        flex-direction: column;
        gap: 15px;
        text-align: center;
        border-radius: 0;
        top: 0;
      }
      
      .file-info-text {
        width: 100%;
      }
      
      .file-info-actions {
        width: 100%;
        flex-direction: column;
      }
      
      .search-box {
        width: 100%;
        max-width: 100%;
      }
      
      .search-input {
        min-width: 0;
      }
      
      .page-section {
        padding: 15px;
      }
      
      .page-header {
        font-size: 18px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 8px;
      }
      
      .paragraph-item {
        padding: 10px;
        font-size: 14px;
      }
      
      .para-checkbox {
        width: 16px;
        height: 16px;
      }
      
      .page-actions {
        flex-wrap: wrap;
      }
      
      .page-btn {
        font-size: 12px;
        padding: 6px 12px;
      }
      
      .search-match-item {
        font-size: 12px;
        padding: 6px 12px;
      }
      
      .btn {
        width: 100%;
      }
      
      .notes-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .notes-actions {
        width: 100%;
        justify-content: flex-start;
      }
      
      .notes-display {
        min-height: 80px;
        height: 100px;
        font-size: 13px;
        resize: none;
      }
      
      .notes-resize-handle {
        display: block;
      }
      
      .speed-control {
        flex-direction: column;
        align-items: stretch;
      }
      
      .speed-label {
        min-width: auto;
      }
      
      .floating-btn {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 14px;
      }
      
      .scroll-top-btn {
        bottom: 80px;
        right: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .last-copied-btn {
        bottom: 135px;
        right: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .back-floating-btn {
        top: 15px;
        left: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .theme-toggle-btn {
        top: 15px;
        left: 70px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
    }
    
    @media (max-width: 480px) {
      .header h1 {
        font-size: 20px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }
      
      .paragraph-item {
        padding: 8px;
        font-size: 12px;
      }
      
      .page-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .notes-title {
        font-size: 14px;
      }
      
      .notes-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .floating-btn {
        padding: 10px 15px;
        font-size: 12px;
      }
      
      .scroll-top-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .last-copied-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .back-floating-btn {
        top: 10px;
        left: 10px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .theme-toggle-btn {
        top: 10px;
        left: 60px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìÑ PDF & EPUB Paragraph Extractor</h1>
      <p>Upload a PDF or EPUB and copy paragraphs with ease</p>
      <p style="margin-top: 10px;"><a href="index.html" style="color: white; text-decoration: underline;">Go to File Manager</a></p>
    </div>
    
    <div class="upload-section" id="uploadSection" style="display: none;">
      <div class="upload-box" id="uploadBox">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Redirecting to File Manager...</div>
      </div>
    </div>
    
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>Extracting paragraphs...</p>
    </div>
    
    <div class="results" id="results">
      <div class="file-info">
        <div class="file-info-text">
          <strong>File:</strong> <span id="fileName"></span><br>
          <strong>Paragraphs:</strong> <span id="paraCount"></span>
        </div>
        <div class="file-info-actions">
          <div class="search-box">
            <input 
              type="text" 
              id="searchInput" 
              class="search-input" 
              placeholder="Search text..."
              oninput="searchParagraphs()"
            >
            <div class="search-loading" id="searchLoading"></div>
            <button class="search-clear-btn" onclick="clearSearch()" title="Clear search">‚úï</button>
          </div>
          <button class="page-btn" onclick="openQuotesViewer()" title="View saved quotes and meanings" style="white-space: nowrap;">
            üìö My Library
          </button>
        </div>
      </div>
      
      <div class="search-results" id="searchResults"></div>
      
      <div id="paragraphsContainer"></div>
    </div>
  </div>
  
  <button class="floating-btn" id="copyAllBtn" style="display: none;" onclick="copyAll()">
    üìã Copy All
  </button>
  
  <button class="scroll-top-btn" id="scrollTopBtn" onclick="scrollToTop()" title="Scroll to top">
    ‚¨ÜÔ∏è
  </button>
  
  <button class="last-copied-btn" id="lastCopiedBtn" onclick="scrollToLastCopied()" title="Go to last copied page">
    üìç
  </button>
  
  <button class="back-floating-btn" onclick="goBackToManager()" title="Back to File Manager">
    ‚¨ÖÔ∏è
  </button>
  
  <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle dark mode" id="themeToggle">
    üåô
  </button>
  
  <!-- Fullscreen Notes Modal -->
  <div class="notes-fullscreen-modal" id="fullscreenModal">
    <div class="fullscreen-header">
      <div class="fullscreen-title" id="fullscreenTitle">Notes</div>
      <div style="display: flex; gap: 10px; align-items: center;">
        <button class="notes-btn edit-toggle" id="fullscreen-edit-toggle" onclick="toggleFullscreenEdit()" title="Enable/Disable editing">
          üîí Locked
        </button>
        <button class="fullscreen-close" onclick="closeFullscreenNotes()">‚úï</button>
      </div>
    </div>
    <div class="fullscreen-content">
      <div 
        class="fullscreen-notes" 
        contenteditable="false"
        data-placeholder="Add your notes here..."
        id="fullscreenNotesContent"
      ></div>
    </div>
    
    <!-- Definition Popup inside fullscreen modal -->
    <div class="definition-popup" id="definitionPopupFullscreen">
      <div class="definition-header">
        <span class="definition-word" id="definitionWordFullscreen"></span>
        <button class="definition-close" onclick="closeDefinitionPopup()">‚úï</button>
      </div>
      <div class="definition-content" id="definitionContentFullscreen">
        <div class="definition-loading">
          <div class="definition-spinner"></div>
          <div>Loading definition...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Definition Popup for regular notes -->
  <div class="definition-popup" id="definitionPopup">
    <div class="definition-header">
      <span class="definition-word" id="definitionWord"></span>
      <button class="definition-close" onclick="closeDefinitionPopup()">‚úï</button>
    </div>
    <div class="definition-content" id="definitionContent">
      <div class="definition-loading">
        <div class="definition-spinner"></div>
        <div>Loading definition...</div>
      </div>
    </div>
  </div>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    // ============================================
    // API CONFIGURATION - IMPORTANT!
    // ============================================
    // 1. Get your FREE Merriam-Webster API key from: https://dictionaryapi.com/
    // 2. Replace 'YOUR_API_KEY_HERE' below with your actual API key
    // 3. Choose your dictionary type based on which API key you registered for
    
    const MERRIAM_WEBSTER_API_KEY = '26a3dfd8-3521-4794-9d0d-89225376adbc'; // ‚ö†Ô∏è Your API key
    const MERRIAM_WEBSTER_DICTIONARY = 'sd3'; // Try 'sd3' (School Dictionary) or 'learners'
    
    // Available dictionaries (you need separate API keys for each):
    // - 'collegiate': Merriam-Webster's Collegiate Dictionary (general use)
    // - 'learners': Learner's Dictionary (for English learners) 
    // - 'sd3': School Dictionary (Elementary Dictionary)
    // - 'medical': Medical Dictionary
    // - 'spanish': Spanish-English Dictionary
    // 
    // NOTE: Each dictionary requires its own API key registration!
    // If you get 403 errors, your key might be for a different dictionary.
    // ============================================
    
    let allParagraphs = [];
    let allPageData = []; // Store complete page data
    let db;
    let lastCopiedPageNum = null;
    let currentFileName = '';
    let currentFileId = null;
    let scrollRestorePosition = 0;
    
    const uploadBox = document.getElementById('uploadBox');
    const fileInput = document.getElementById('fileInput');
    const uploadSection = document.getElementById('uploadSection');
    const loading = document.getElementById('loading');
    const results = document.getElementById('results');
    const copyAllBtn = document.getElementById('copyAllBtn');
    const scrollTopBtn = document.getElementById('scrollTopBtn');
    const lastCopiedBtn = document.getElementById('lastCopiedBtn');
    
    // IndexedDB setup
    const dbName = 'FileExtractorDB';
    const storeName = 'files';
    const notesStoreName = 'pageNotes';
    let pageNotes = {};
    
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 4);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains(notesStoreName)) {
            db.createObjectStore(notesStoreName, { keyPath: 'pageKey' });
          }
          if (!db.objectStoreNames.contains('savedQuotes')) {
            db.createObjectStore('savedQuotes', { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains('savedMeanings')) {
            db.createObjectStore('savedMeanings', { keyPath: 'id', autoIncrement: true });
          }
        };
      });
    }
    
    async function savePageNote(pageKey, note) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.put({ pageKey, note });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadPageNotes() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.getAll();
        
        request.onsuccess = () => {
          const notes = {};
          request.result.forEach(item => {
            notes[item.pageKey] = item.note;
          });
          resolve(notes);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveLastCopiedPage(fileName, pageNum) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = `${fileName}_lastCopied`;
        const request = objectStore.put({ pageKey, note: pageNum.toString() });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveCurrentFileState(fileId, fileName, scrollPosition) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = '_currentFileState';
        const request = objectStore.put({ 
          pageKey, 
          note: JSON.stringify({ fileId, fileName, scrollPosition, timestamp: Date.now() })
        });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadCurrentFileState() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = '_currentFileState';
        const request = objectStore.get(pageKey);
        
        request.onsuccess = () => {
          if (request.result && request.result.note) {
            try {
              resolve(JSON.parse(request.result.note));
            } catch (e) {
              resolve(null);
            }
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadLastCopiedPage(fileName) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = `${fileName}_lastCopied`;
        const request = objectStore.get(pageKey);
        
        request.onsuccess = () => {
          if (request.result && request.result.note) {
            resolve(parseInt(request.result.note));
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getFileById(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([storeName], 'readonly');
        const objectStore = transaction.objectStore(storeName);
        const request = objectStore.get(id);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Preload speech voices (important for mobile)
    if ('speechSynthesis' in window) {
      // Trigger voice loading
      window.speechSynthesis.getVoices();
      window.speechSynthesis.addEventListener('voiceschanged', () => {
        console.log('Voices loaded:', window.speechSynthesis.getVoices().length);
      });
    }
    
    // Check if file was selected from upload page or restore from state
    window.addEventListener('load', async () => {
      await initDB();
      pageNotes = await loadPageNotes();
      
      // Check for new file from upload page
      let fileIdToLoad = localStorage.getItem('currentFileId');
      
      if (fileIdToLoad) {
        // New file selected from upload page
        localStorage.removeItem('currentFileId');
        currentFileId = parseInt(fileIdToLoad);
      } else {
        // Try to restore previous state (refresh scenario)
        const savedState = await loadCurrentFileState();
        if (savedState && savedState.fileId) {
          currentFileId = savedState.fileId;
          scrollRestorePosition = savedState.scrollPosition || 0;
        }
      }
      
      if (currentFileId) {
        const fileData = await getFileById(currentFileId);
        
        if (fileData) {
          // Convert data URL back to file
          fetch(fileData.data)
            .then(res => res.blob())
            .then(blob => {
              const newFile = new File([blob], fileData.name, { type: blob.type });
              processFile(newFile);
            });
        } else {
          // File not found, redirect to file manager
          window.location.href = 'upload.html';
        }
      } else {
        // No file selected, redirect to file manager
        window.location.href = 'upload.html';
      }
    });
    
    // Disable drag and drop and file input on extractor page
    // Users should upload from the file manager page only
    
    async function processFile(file) {
      if (file.name.endsWith('.epub')) {
        await processEPUB(file);
      } else {
        await processPDF(file);
      }
    }
    
    async function processEPUB(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const JSZip = window.JSZip || await loadJSZip();
        const zip = await JSZip.loadAsync(file);
        
        // Find all HTML/XHTML files in the EPUB
        const htmlFiles = Object.keys(zip.files).filter(name => 
          name.match(/\.(html|xhtml|htm)$/i) && !name.startsWith('__MACOSX')
        );
        
        const pageData = [];
        let pageNum = 1;
        
        for (const fileName of htmlFiles) {
          const content = await zip.files[fileName].async('text');
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          
          // Remove script and style tags
          doc.querySelectorAll('script, style').forEach(el => el.remove());
          
          // Extract ALL text content from the HTML
          const paragraphs = [];
          
          // Get all text-containing elements
          const textElements = doc.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6, li, td, th, span, blockquote, pre, code');
          
          textElements.forEach(el => {
            // Skip if this element's text is already captured by a parent
            const hasTextParent = Array.from(textElements).some(parent => 
              parent !== el && parent.contains(el)
            );
            
            if (!hasTextParent) {
              const text = el.textContent.trim();
              if (text.length > 0) { // Keep all text, no minimum length
                paragraphs.push(text);
              }
            }
          });
          
          // If no structured elements found, get all text from body
          if (paragraphs.length === 0) {
            const bodyText = doc.body?.textContent.trim();
            if (bodyText) {
              // Split by double line breaks to create paragraphs
              const textParagraphs = bodyText.split(/\n\s*\n/).filter(p => p.trim().length > 0);
              paragraphs.push(...textParagraphs);
            }
          }
          
          if (paragraphs.length > 0) {
            pageData.push({
              pageNum: pageNum++,
              paragraphs: paragraphs
            });
          }
        }
        
        if (pageData.length === 0) {
          throw new Error('No readable content found in EPUB');
        }
        
        // Flatten for allParagraphs array
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        allPageData = pageData;
        
        displayResults(file.name, pageData);
      } catch (error) {
        console.error('Error processing EPUB:', error);
        resetApp();
      }
    }
    
    async function loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    

    
    async function processPDF(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        const pageData = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          
          // Group text items by line based on Y position
          const lines = [];
          let currentLine = { items: [], y: null };
          
          textContent.items.forEach(item => {
            if (!item.str || item.str.trim() === '') return; // Skip empty items
            
            const y = Math.round(item.transform[5]);
            
            // If this is a new line (different Y position)
            if (currentLine.y === null || Math.abs(currentLine.y - y) > 3) {
              if (currentLine.items.length > 0) {
                lines.push(currentLine);
              }
              currentLine = { items: [item], y: y };
            } else {
              // Same line, add to current line
              currentLine.items.push(item);
            }
          });
          
          // Add the last line
          if (currentLine.items.length > 0) {
            lines.push(currentLine);
          }
          
          // Sort lines by Y position (top to bottom)
          lines.sort((a, b) => b.y - a.y);
          
          // Build paragraphs from lines with simpler logic
          const paragraphs = [];
          let currentParagraph = '';
          let lastLineY = null;
          
          lines.forEach(line => {
            // Sort items in line by X position (left to right)
            line.items.sort((a, b) => a.transform[4] - b.transform[4]);
            
            // Combine items in line to form text
            const lineText = line.items.map(item => item.str).join(' ').trim();
            
            if (!lineText) return; // Skip empty lines
            
            // Check for paragraph break (larger vertical gap)
            const verticalGap = lastLineY !== null ? (lastLineY - line.y) : 0;
            const isLargeGap = verticalGap > 15; // Paragraph break threshold
            
            if (currentParagraph && isLargeGap) {
              // Save current paragraph and start new one
              paragraphs.push(currentParagraph.trim());
              currentParagraph = lineText;
            } else {
              // Continue current paragraph
              if (currentParagraph) {
                // Add space between lines unless previous line ends with hyphen
                if (currentParagraph.endsWith('-')) {
                  currentParagraph = currentParagraph.slice(0, -1) + lineText;
                } else {
                  currentParagraph += ' ' + lineText;
                }
              } else {
                currentParagraph = lineText;
              }
            }
            
            lastLineY = line.y;
          });
          
          // Add the last paragraph
          if (currentParagraph.trim()) {
            paragraphs.push(currentParagraph.trim());
          }
          
          // Clean up paragraphs - only remove excessive whitespace, keep all content
          const cleanParas = paragraphs
            .map(p => p.replace(/\s+/g, ' ').trim())
            .filter(p => p.length > 0); // Keep everything, even short text
          
          pageData.push({
            pageNum: i,
            paragraphs: cleanParas.length > 0 ? cleanParas : ['No text found on this page']
          });
        }
        
        // Flatten for allParagraphs array and store complete page data
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        allPageData = pageData;
        
        displayResults(file.name, pageData);
      } catch (error) {
        console.error('Error processing PDF:', error);
        resetApp();
      }
    }
    
    async function displayResults(fileName, pageData) {
      loading.classList.remove('show');
      results.classList.add('show');
      copyAllBtn.style.display = 'block';
      
      // Store current file name
      currentFileName = fileName;
      
      // Save current file state for refresh persistence
      await saveCurrentFileState(currentFileId, fileName, 0);
      
      // Load last copied page for this file
      const savedLastCopied = await loadLastCopiedPage(fileName);
      if (savedLastCopied !== null) {
        lastCopiedPageNum = savedLastCopied;
        lastCopiedBtn.classList.add('show');
      }
      
      const totalParas = pageData.reduce((sum, p) => sum + p.paragraphs.length, 0);
      document.getElementById('fileName').textContent = fileName;
      document.getElementById('paraCount').textContent = totalParas;
      
      const container = document.getElementById('paragraphsContainer');
      let globalIndex = 0;
      
      container.innerHTML = pageData.map(page => {
        const pageStartIdx = globalIndex;
        const pageKey = `${fileName}_page_${page.pageNum}`;
        const savedNote = pageNotes[pageKey] || '';
        
        const pageHTML = `
          <div class="page-section" data-page="${page.pageNum}">
            <div class="page-header">Page ${page.pageNum}</div>
            <div class="paragraphs-grid">
              ${page.paragraphs.map((p, i) => {
                const idx = globalIndex++;
                return `
                  <div class="paragraph-item" id="para-btn-${idx}">
                    <input type="checkbox" class="para-checkbox" id="check-${idx}" data-index="${idx}" onclick="event.stopPropagation(); toggleParagraph(${idx})">
                    <label onclick="copyParagraph(${idx})">P${i + 1}</label>
                  </div>
                `;
              }).join('')}
            </div>
            <div class="page-actions">
              <button class="page-btn" onclick="selectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Select All</button>
              <button class="page-btn" onclick="deselectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Deselect All</button>
              <button class="page-btn" onclick="copySelectedInPage(event, ${pageStartIdx}, ${globalIndex})">Copy Selected</button>
              <button class="page-btn" style="background: #4CAF50;" onclick="copyAllInPage(event, ${pageStartIdx}, ${globalIndex})">üìã Copy All Page</button>
              <button class="page-btn" style="background: #9C27B0;" onclick="copyPageToNotes(event, '${pageKey}', ${pageStartIdx}, ${globalIndex}, ${page.pageNum})">üìù Copy to Notes</button>
            </div>
            <div class="page-notes">
              <div class="notes-header">
                <span class="notes-title">üìù Notes</span>
                <div class="notes-actions">
                  <button class="notes-btn" id="speak-btn-${page.pageNum}" onclick="toggleSpeech('${pageKey}', ${page.pageNum})" title="Play/Pause speech">
                    üîä Speak
                  </button>
                  <button class="notes-btn rewind" id="rewind-btn-${page.pageNum}" onclick="event.stopPropagation(); skipBackward(${page.pageNum})" title="Skip backward 15s" style="display: none;">
                    ‚è™
                  </button>
                  <button class="notes-btn forward" id="forward-btn-${page.pageNum}" onclick="event.stopPropagation(); skipForward(${page.pageNum})" title="Skip forward 15s" style="display: none;">
                    ‚è©
                  </button>
                  <button class="notes-btn stop" id="stop-btn-${page.pageNum}" onclick="stopSpeech(${page.pageNum})" title="Stop speech" style="display: none;">
                    ‚èπÔ∏è
                  </button>
                  <button class="notes-btn font-control" onclick="changeFontSize('${pageKey}', -1)" title="Decrease font size">
                    A-
                  </button>
                  <button class="notes-btn font-control" onclick="changeFontSize('${pageKey}', 1)" title="Increase font size">
                    A+
                  </button>
                  <button class="notes-btn fullscreen" onclick="openFullscreenNotes('${pageKey}', ${page.pageNum})" title="View in fullscreen">
                    ‚õ∂ Fullscreen
                  </button>
                  <button class="notes-btn edit-toggle" id="edit-toggle-${page.pageNum}" onclick="toggleNotesEdit('${pageKey}', ${page.pageNum})" title="Enable/Disable editing">
                    üîí Locked
                  </button>
                  <span class="notes-saved" id="saved-${page.pageNum}">‚úì Saved</span>
                </div>
              </div>
              <div class="speed-control">
                <label class="speed-label">Speed: <span class="speed-value" id="speed-value-${page.pageNum}">1.0x</span></label>
                <input 
                  type="range" 
                  class="speed-slider" 
                  id="speed-${page.pageNum}"
                  min="0.5" 
                  max="2.0" 
                  step="0.1" 
                  value="1.0"
                  oninput="updateSpeedDisplay(${page.pageNum})"
                  title="Adjust speech speed"
                >
              </div>
              <div 
                class="notes-display" 
                contenteditable="false"
                data-placeholder="Add your notes for this page..."
                data-page-key="${pageKey}"
                data-page-num="${page.pageNum}"
              >${savedNote}</div>
              <div class="notes-resize-handle" data-page-key="${pageKey}">
                ‚ãÆ‚ãÆ‚ãÆ Drag to resize
              </div>
            </div>
          </div>
        `;
        return pageHTML;
      }).join('');
      
      // Add resize functionality for mobile
      setTimeout(() => {
        document.querySelectorAll('.notes-resize-handle').forEach(handle => {
          let startY, startHeight, notesDiv;
          
          const onStart = (e) => {
            const pageKey = handle.dataset.pageKey;
            notesDiv = document.querySelector('[data-page-key="' + pageKey + '"]');
            if (!notesDiv) return;
            
            startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            startHeight = notesDiv.offsetHeight;
            
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);
            
            e.preventDefault();
          };
          
          const onMove = (e) => {
            if (!notesDiv) return;
            
            const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            const diff = currentY - startY;
            const newHeight = Math.max(80, Math.min(400, startHeight + diff));
            
            notesDiv.style.height = newHeight + 'px';
            e.preventDefault();
          };
          
          const onEnd = () => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onEnd);
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onEnd);
            notesDiv = null;
          };
          
          handle.addEventListener('mousedown', onStart);
          handle.addEventListener('touchstart', onStart, { passive: false });
        });
      }, 100);
      
      // Restore scroll position after a short delay to ensure content is rendered
      if (scrollRestorePosition > 0) {
        setTimeout(() => {
          window.scrollTo({
            top: scrollRestorePosition,
            behavior: 'auto'
          });
          scrollRestorePosition = 0; // Reset after restoring
        }, 100);
      }
    }
    
    // Notes are now read-only, no need for handleNoteChange function
    
    // Text-to-Speech functionality
    let currentSpeech = null;
    let currentSpeakingPage = null;
    let originalText = '';
    let highlightInterval = null;
    let isPaused = false;
    let pausedAtWord = 0;
    let allWords = [];
    let currentSpeed = 1.0;
    
    function updateSpeedDisplay(pageNum) {
      const slider = document.getElementById(`speed-${pageNum}`);
      const display = document.getElementById(`speed-value-${pageNum}`);
      display.textContent = slider.value + 'x';
    }
    
    // Font size control for notes
    function changeFontSize(pageKey, delta) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      if (!notesDiv) return;
      
      const currentSize = parseInt(window.getComputedStyle(notesDiv).fontSize);
      const newSize = Math.max(10, Math.min(24, currentSize + delta));
      notesDiv.style.fontSize = newSize + 'px';
    }
    
    // Toggle notes editing
    function toggleNotesEdit(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const toggleBtn = document.getElementById(`edit-toggle-${pageNum}`);
      
      if (!notesDiv || !toggleBtn) return;
      
      const isEditable = notesDiv.contentEditable === 'true';
      
      if (isEditable) {
        // Lock editing
        notesDiv.contentEditable = 'false';
        notesDiv.style.cursor = 'default';
        toggleBtn.innerHTML = 'üîí Locked';
        toggleBtn.classList.remove('unlocked');
        toggleBtn.title = 'Click to enable editing';
      } else {
        // Unlock editing
        notesDiv.contentEditable = 'true';
        notesDiv.style.cursor = 'text';
        toggleBtn.innerHTML = 'üîì Unlocked';
        toggleBtn.classList.add('unlocked');
        toggleBtn.title = 'Click to disable editing';
        
        // Add input listener for auto-save when editing is enabled
        notesDiv.oninput = () => handleNotesInput(pageKey, pageNum);
      }
    }
    
    // Handle notes input for auto-save
    let notesInputTimeout;
    async function handleNotesInput(pageKey, pageNum) {
      clearTimeout(notesInputTimeout);
      
      notesInputTimeout = setTimeout(async () => {
        const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
        if (!notesDiv) return;
        
        const noteContent = notesDiv.innerHTML;
        pageNotes[pageKey] = noteContent;
        await savePageNote(pageKey, noteContent);
        
        // Show saved indicator
        const savedIndicator = document.getElementById(`saved-${pageNum}`);
        if (savedIndicator) {
          savedIndicator.classList.add('show');
          setTimeout(() => {
            savedIndicator.classList.remove('show');
          }, 2000);
        }
      }, 1000);
    }
    
    // Toggle fullscreen notes editing
    function toggleFullscreenEdit() {
      const fullscreenContent = document.getElementById('fullscreenNotesContent');
      const toggleBtn = document.getElementById('fullscreen-edit-toggle');
      
      if (!fullscreenContent || !toggleBtn) return;
      
      const isEditable = fullscreenContent.contentEditable === 'true';
      
      if (isEditable) {
        // Lock editing
        fullscreenContent.contentEditable = 'false';
        fullscreenContent.style.cursor = 'default';
        toggleBtn.innerHTML = 'üîí Locked';
        toggleBtn.classList.remove('unlocked');
        toggleBtn.title = 'Click to enable editing';
      } else {
        // Unlock editing
        fullscreenContent.contentEditable = 'true';
        fullscreenContent.style.cursor = 'text';
        toggleBtn.innerHTML = 'üîì Unlocked';
        toggleBtn.classList.add('unlocked');
        toggleBtn.title = 'Click to disable editing';
        
        // Add input listener for auto-save
        fullscreenContent.oninput = () => handleFullscreenNotesInput();
      }
    }
    
    // Handle fullscreen notes input
    let fullscreenInputTimeout;
    async function handleFullscreenNotesInput() {
      if (!currentFullscreenPageKey || !currentFullscreenPageNum) return;
      
      clearTimeout(fullscreenInputTimeout);
      
      fullscreenInputTimeout = setTimeout(async () => {
        const fullscreenContent = document.getElementById('fullscreenNotesContent');
        const notesDiv = document.querySelector(`[data-page-key="${currentFullscreenPageKey}"]`);
        
        if (!fullscreenContent || !notesDiv) return;
        
        // Sync content back to original notes
        notesDiv.innerHTML = fullscreenContent.innerHTML;
        
        // Save to database
        const noteContent = fullscreenContent.innerHTML;
        pageNotes[currentFullscreenPageKey] = noteContent;
        await savePageNote(currentFullscreenPageKey, noteContent);
        
        // Show saved indicator
        const savedIndicator = document.getElementById(`saved-${currentFullscreenPageNum}`);
        if (savedIndicator) {
          savedIndicator.classList.add('show');
          setTimeout(() => {
            savedIndicator.classList.remove('show');
          }, 2000);
        }
      }, 1000);
    }
    
    // Stop speech completely
    function stopSpeech(pageNum) {
      if (currentSpeech && currentSpeakingPage === pageNum) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        
        const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
        const stopBtn = document.getElementById(`stop-btn-${pageNum}`);
        const rewindBtn = document.getElementById(`rewind-btn-${pageNum}`);
        const forwardBtn = document.getElementById(`forward-btn-${pageNum}`);
        const notesDiv = document.querySelector(`[data-page-num="${pageNum}"]`);
        
        if (speakBtn) {
          speakBtn.classList.remove('speaking', 'paused');
          speakBtn.innerHTML = 'üîä Speak';
        }
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        if (rewindBtn) {
          rewindBtn.style.display = 'none';
        }
        if (forwardBtn) {
          forwardBtn.style.display = 'none';
        }
        if (notesDiv) {
          clearHighlights(notesDiv);
        }
        
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
        speechStartTime = 0;
        elapsedTime = 0;
      }
    }
    
    // Skip backward 15 seconds
    function skipBackward(pageNum) {
      console.log('Skip backward clicked', {pageNum, currentSpeakingPage, allWordsLength: allWords.length, pausedAtWord});
      
      if (currentSpeakingPage !== pageNum) {
        console.log('Not currently speaking this page');
        return;
      }
      
      if (!allWords.length) {
        console.log('No words available');
        return;
      }
      
      // Calculate approximate words per second
      const baseWPM = 150;
      const adjustedWPM = baseWPM * currentSpeed;
      const wordsPerSecond = adjustedWPM / 60;
      const wordsToSkip = Math.floor(wordsPerSecond * 15); // 15 seconds
      
      // Calculate new position
      const newWordIndex = Math.max(0, pausedAtWord - wordsToSkip);
      
      console.log(`Skipping backward from word ${pausedAtWord} to ${newWordIndex} (${wordsToSkip} words)`);
      
      // Restart from new position
      restartSpeechFromWord(pageNum, newWordIndex);
    }
    
    // Skip forward 15 seconds
    function skipForward(pageNum) {
      console.log('Skip forward clicked', {pageNum, currentSpeakingPage, allWordsLength: allWords.length, pausedAtWord});
      
      if (currentSpeakingPage !== pageNum) {
        console.log('Not currently speaking this page');
        return;
      }
      
      if (!allWords.length) {
        console.log('No words available');
        return;
      }
      
      // Calculate approximate words per second
      const baseWPM = 150;
      const adjustedWPM = baseWPM * currentSpeed;
      const wordsPerSecond = adjustedWPM / 60;
      const wordsToSkip = Math.floor(wordsPerSecond * 15); // 15 seconds
      
      // Calculate new position
      const newWordIndex = Math.min(allWords.length - 1, pausedAtWord + wordsToSkip);
      
      console.log(`Skipping forward from word ${pausedAtWord} to ${newWordIndex} (${wordsToSkip} words)`);
      
      // Restart from new position
      restartSpeechFromWord(pageNum, newWordIndex);
    }
    
    // Restart speech from a specific word
    function restartSpeechFromWord(pageNum, wordIndex) {
      const pageKey = `${currentFileName}_page_${pageNum}`;
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const speedSlider = document.getElementById(`speed-${pageNum}`);
      const stopBtn = document.getElementById(`stop-btn-${pageNum}`);
      
      if (!notesDiv || !allWords.length) return;
      
      // Cancel current speech
      window.speechSynthesis.cancel();
      clearInterval(highlightInterval);
      
      // Get remaining text from word index
      const remainingWords = allWords.slice(wordIndex);
      const remainingText = remainingWords.join(' ');
      
      if (!remainingText) {
        stopSpeech(pageNum);
        return;
      }
      
      // Update paused position
      pausedAtWord = wordIndex;
      
      // Start speech from new position
      const speed = currentSpeed;
      let currentWordIndex = wordIndex;
      let boundarySupported = false;
      
      // Create new speech utterance
      currentSpeech = new SpeechSynthesisUtterance(remainingText);
      currentSpeech.rate = speed;
      currentSpeech.pitch = 1.0;
      currentSpeech.volume = 1.0;
      
      // Try to get a voice
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
        const englishVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
        currentSpeech.voice = englishVoice;
        currentSpeech.lang = englishVoice.lang;
      } else {
        currentSpeech.lang = 'en-US';
      }
      
      // Boundary events
      currentSpeech.onboundary = (event) => {
        if (event.name === 'word' && event.charIndex !== undefined) {
          if (!boundarySupported) {
            boundarySupported = true;
            if (highlightInterval) {
              clearInterval(highlightInterval);
              highlightInterval = null;
            }
          }
          
          // Calculate position in full text
          let charCount = 0;
          for (let i = 0; i < wordIndex; i++) {
            charCount += allWords[i].length + 1;
          }
          charCount += event.charIndex;
          
          highlightTextAtPosition(notesDiv, charCount, originalText);
          
          // Track word position
          let localCharCount = 0;
          for (let i = 0; i < remainingWords.length; i++) {
            if (localCharCount >= event.charIndex) {
              pausedAtWord = wordIndex + i;
              break;
            }
            localCharCount += remainingWords[i].length + 1;
          }
        }
      };
      
      // Start event
      currentSpeech.onstart = () => {
        const baseWPM = 150;
        const adjustedWPM = baseWPM * speed;
        const avgWordDuration = (60000 / adjustedWPM);
        
        if (allWords.length > currentWordIndex) {
          highlightWordByIndex(notesDiv, currentWordIndex, allWords);
          currentWordIndex++;
        }
        
        highlightInterval = setInterval(() => {
          if (!boundarySupported && currentWordIndex < allWords.length) {
            highlightWordByIndex(notesDiv, currentWordIndex, allWords);
            pausedAtWord = currentWordIndex;
            currentWordIndex++;
          } else if (boundarySupported && highlightInterval) {
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
        }, avgWordDuration);
      };
      
      // End event
      currentSpeech.onend = () => {
        const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
        const rewindBtn = document.getElementById(`rewind-btn-${pageNum}`);
        const forwardBtn = document.getElementById(`forward-btn-${pageNum}`);
        
        if (speakBtn) {
          speakBtn.classList.remove('speaking', 'paused');
          speakBtn.innerHTML = 'üîä Speak';
        }
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        if (rewindBtn) {
          rewindBtn.style.display = 'none';
        }
        if (forwardBtn) {
          forwardBtn.style.display = 'none';
        }
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
        pausedAtWord = 0;
      };
      
      // Error event
      currentSpeech.onerror = (event) => {
        if (event.error === 'interrupted' || event.error === 'canceled') {
          return;
        }
        console.error('Speech synthesis error:', event.error);
        stopSpeech(pageNum);
      };
      
      // Start speaking
      setTimeout(() => {
        window.speechSynthesis.cancel();
        setTimeout(() => {
          window.speechSynthesis.speak(currentSpeech);
        }, 50);
      }, 100);
    }
    
    function clearHighlights(notesDiv) {
      if (originalText) {
        // Clear highlights in both places
        const modal = document.getElementById('fullscreenModal');
        const fullscreenDiv = document.getElementById('fullscreenNotesContent');
        
        if (notesDiv) {
          notesDiv.textContent = originalText;
        }
        
        if (modal && modal.classList.contains('show') && fullscreenDiv) {
          fullscreenDiv.textContent = originalText;
        }
        
        originalText = '';
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function scrollToHighlight(notesDiv) {
      const highlightedWord = notesDiv.querySelector('.highlight-word');
      if (!highlightedWord) return;
      
      // Get the position of the highlighted word relative to the container
      const containerRect = notesDiv.getBoundingClientRect();
      const wordRect = highlightedWord.getBoundingClientRect();
      
      // Calculate relative positions
      const wordTopRelative = wordRect.top - containerRect.top;
      const wordBottomRelative = wordRect.bottom - containerRect.top;
      
      // Define visible area with padding (keep word away from edges)
      const topPadding = 30;
      const bottomPadding = 30;
      const visibleTop = topPadding;
      const visibleBottom = notesDiv.clientHeight - bottomPadding;
      
      // Check if word is outside the comfortable visible area
      if (wordTopRelative < visibleTop) {
        // Word is above visible area - scroll up
        notesDiv.scrollTop += (wordTopRelative - visibleTop);
      } else if (wordBottomRelative > visibleBottom) {
        // Word is below visible area - scroll down
        notesDiv.scrollTop += (wordBottomRelative - visibleBottom);
      }
    }
    
    function highlightTextAtPosition(notesDiv, charIndex, text) {
      // Use fullscreen modal if open
      const modal = document.getElementById('fullscreenModal');
      const targetDiv = (modal && modal.classList.contains('show')) 
        ? document.getElementById('fullscreenNotesContent') 
        : notesDiv;
      
      if (!targetDiv) return;
      
      // Find word boundaries around the character position
      let wordStart = charIndex;
      let wordEnd = charIndex;
      
      // Find start of word
      while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) {
        wordStart--;
      }
      
      // Find end of word
      while (wordEnd < text.length && !/\s/.test(text[wordEnd])) {
        wordEnd++;
      }
      
      // Build HTML with highlighted word
      const before = escapeHtml(text.substring(0, wordStart));
      const word = escapeHtml(text.substring(wordStart, wordEnd));
      const after = escapeHtml(text.substring(wordEnd));
      
      targetDiv.innerHTML = before + '<span class="highlight-word">' + word + '</span>' + after;
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(targetDiv);
    }
    
    function highlightWordByIndex(notesDiv, wordIndex, words) {
      // Use fullscreen modal if open
      const modal = document.getElementById('fullscreenModal');
      const targetDiv = (modal && modal.classList.contains('show')) 
        ? document.getElementById('fullscreenNotesContent') 
        : notesDiv;
      
      if (!targetDiv) return;
      
      const htmlParts = words.map((word, idx) => {
        if (idx === wordIndex) {
          return '<span class="highlight-word">' + escapeHtml(word) + '</span>';
        }
        return escapeHtml(word);
      });
      targetDiv.innerHTML = htmlParts.join(' ');
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(targetDiv);
    }
    
    function toggleSpeech(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
      const stopBtn = document.getElementById(`stop-btn-${pageNum}`);
      const speedSlider = document.getElementById(`speed-${pageNum}`);
      
      if (!notesDiv || !speakBtn || !speedSlider) {
        console.error('Required elements not found');
        return;
      }
      
      const noteText = notesDiv.textContent.trim();
      
      // If currently speaking this page, toggle pause/resume
      if (currentSpeakingPage === pageNum && currentSpeech) {
        if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
          // Pause
          window.speechSynthesis.pause();
          isPaused = true;
          speakBtn.classList.remove('speaking');
          speakBtn.classList.add('paused');
          speakBtn.innerHTML = '‚ñ∂Ô∏è Resume';
          clearInterval(highlightInterval);
          console.log('Speech paused');
        } else if (window.speechSynthesis.paused) {
          // Resume
          window.speechSynthesis.resume();
          isPaused = false;
          speakBtn.classList.remove('paused');
          speakBtn.classList.add('speaking');
          speakBtn.innerHTML = '‚è∏Ô∏è Pause';
          console.log('Speech resumed');
        }
        return;
      }
      
      // Stop any other speech
      if (currentSpeech) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        if (currentSpeakingPage !== null) {
          const prevBtn = document.getElementById(`speak-btn-${currentSpeakingPage}`);
          const prevNotesDiv = document.querySelector(`[data-page-num="${currentSpeakingPage}"]`);
          if (prevBtn) {
            prevBtn.classList.remove('speaking');
            prevBtn.innerHTML = 'üîä Speak';
          }
          if (prevNotesDiv) {
            clearHighlights(prevNotesDiv);
          }
        }
      }
      
      if (!noteText) {
        console.log('No notes to read');
        return;
      }
      
      // Check if speech synthesis is supported
      if (!('speechSynthesis' in window)) {
        console.error('Text-to-speech is not supported in your browser');
        return;
      }
      
      // Cancel any pending speech
      window.speechSynthesis.cancel();
      
      // Store original text
      originalText = noteText;
      
      // Split text into words for fallback highlighting
      const words = noteText.split(/\s+/);
      allWords = words; // Store globally for skip functions
      pausedAtWord = 0; // Reset position
      let currentWordIndex = 0;
      let boundarySupported = false;
      
      // No truncation - we'll handle long text properly
      let textToSpeak = noteText;
      
      // Create and configure speech
      currentSpeech = new SpeechSynthesisUtterance(textToSpeak);
      currentSpeakingPage = pageNum;
      
      // Configure speech properties with user-selected speed
      const speed = parseFloat(speedSlider.value);
      currentSpeed = speed; // Store globally for skip functions
      currentSpeech.rate = speed;
      currentSpeech.pitch = 1.0;
      currentSpeech.volume = 1.0;
      
      // Try to get a voice (helps with mobile)
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
        // Prefer English voices
        const englishVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
        currentSpeech.voice = englishVoice;
        currentSpeech.lang = englishVoice.lang;
      } else {
        currentSpeech.lang = 'en-US';
      }
      
      console.log('Starting speech with text:', textToSpeak.substring(0, 50) + '...');
      console.log('Speech rate:', speed);
      console.log('Available voices:', voices.length);
      
      // Update button state
      speakBtn.classList.add('speaking');
      speakBtn.innerHTML = '‚è∏Ô∏è Pause';
      if (stopBtn) {
        stopBtn.style.display = 'flex';
      }
      
      // Show skip buttons
      const rewindBtn = document.getElementById(`rewind-btn-${pageNum}`);
      const forwardBtn = document.getElementById(`forward-btn-${pageNum}`);
      if (rewindBtn) {
        rewindBtn.style.display = 'flex';
      }
      if (forwardBtn) {
        forwardBtn.style.display = 'flex';
      }
      
      // Try to use boundary events (more accurate)
      currentSpeech.onboundary = (event) => {
        if (event.name === 'word' && event.charIndex !== undefined) {
          if (!boundarySupported) {
            boundarySupported = true;
            console.log('Using boundary events for accurate highlighting');
            // Clear the fallback interval once we know boundary events work
            if (highlightInterval) {
              clearInterval(highlightInterval);
              highlightInterval = null;
            }
          }
          
          highlightTextAtPosition(notesDiv, event.charIndex, noteText);
          
          // Track word position for pause/resume
          let charCount = 0;
          for (let i = 0; i < words.length; i++) {
            if (charCount >= event.charIndex) {
              pausedAtWord = i;
              break;
            }
            charCount += words[i].length + 1; // +1 for space
          }
        }
      };
      
      // Handle speech start - begin highlighting when speech actually starts
      currentSpeech.onstart = () => {
        console.log('Speech started');
        
        // Calculate word duration based on actual speech rate
        // Average speaking rate is 150 WPM, adjusted by speed setting
        const baseWPM = 150; // Base words per minute
        const adjustedWPM = baseWPM * speed; // Adjust for speed setting
        const avgWordDuration = (60000 / adjustedWPM); // Milliseconds per word
        
        console.log(`Highlighting: ${adjustedWPM} WPM, ${avgWordDuration.toFixed(0)}ms per word`);
        
        // Start highlighting with first word
        if (words.length > 0) {
          highlightWordByIndex(notesDiv, 0, words);
          currentWordIndex = 1;
          pausedAtWord = 0;
        }
        
        // Use fallback only if boundary events don't work
        highlightInterval = setInterval(() => {
          if (!boundarySupported && currentWordIndex < words.length) {
            highlightWordByIndex(notesDiv, currentWordIndex, words);
            pausedAtWord = currentWordIndex;
            currentWordIndex++;
          } else if (boundarySupported && highlightInterval) {
            // Boundary events are working, clear the interval
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
        }, avgWordDuration);
      };
      
      // Handle speech end
      currentSpeech.onend = () => {
        speakBtn.classList.remove('speaking', 'paused');
        speakBtn.innerHTML = 'üîä Speak';
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
      };
      
      // Handle speech error
      currentSpeech.onerror = (event) => {
        console.error('Speech error:', event);
        
        // Ignore "interrupted" and "canceled" errors (these are expected when user stops speech)
        if (event.error === 'interrupted' || event.error === 'canceled') {
          console.log('Speech was stopped by user');
          return;
        }
        
        // Log error details for debugging
        console.error('Speech synthesis error:', event.error);
        speakBtn.classList.remove('speaking', 'paused');
        speakBtn.innerHTML = 'üîä Speak';
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
      };
      
      // Mobile-specific: Load voices first if not loaded
      if (window.speechSynthesis.getVoices().length === 0) {
        window.speechSynthesis.addEventListener('voiceschanged', function loadVoices() {
          const voices = window.speechSynthesis.getVoices();
          if (voices.length > 0 && currentSpeech) {
            const englishVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
            currentSpeech.voice = englishVoice;
            currentSpeech.lang = englishVoice.lang;
          }
          window.speechSynthesis.removeEventListener('voiceschanged', loadVoices);
        });
      }
      
      // Start speaking - with a small delay to ensure everything is ready
      setTimeout(() => {
        try {
          // Mobile fix: Cancel any pending speech first
          window.speechSynthesis.cancel();
          
          // Small delay before speaking (helps on mobile)
          setTimeout(() => {
            window.speechSynthesis.speak(currentSpeech);
            console.log('Speech queued successfully');
          }, 50);
        } catch (error) {
          console.error('Failed to start speech:', error);
          speakBtn.classList.remove('speaking');
          speakBtn.innerHTML = 'üîä Speak';
          if (stopBtn) {
            stopBtn.style.display = 'none';
          }
        }
      }, 100);
    }
    
    function toggleParagraph(index) {
      const checkbox = document.getElementById('check-' + index);
      updateParagraphStyle(index);
    }
    
    function updateParagraphStyle(index) {
      const checkbox = document.getElementById('check-' + index);
      const btn = document.getElementById('para-btn-' + index);
      
      if (checkbox.checked) {
        btn.classList.add('selected');
      } else {
        btn.classList.remove('selected');
      }
    }
    
    function selectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = true;
          updateParagraphStyle(i);
        }
      }
    }
    
    function deselectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = false;
          updateParagraphStyle(i);
        }
      }
    }
    
    async function copySelectedInPage(event, startIdx, endIdx) {
      const selectedTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox && checkbox.checked) {
          selectedTexts.push(allParagraphs[i]);
        }
      }
      
      if (selectedTexts.length === 0) {
        return;
      }
      
      const combinedText = selectedTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(async () => {
        // Store the page number for last copied button
        const pageSection = event.target.closest('.page-section');
        if (pageSection) {
          lastCopiedPageNum = parseInt(pageSection.dataset.page);
          await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
          lastCopiedBtn.classList.add('show');
        }
        showCopyFeedback(event.target);
      });
    }
    
    async function copyAllInPage(event, startIdx, endIdx) {
      const pageTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        pageTexts.push(allParagraphs[i]);
      }
      
      const combinedText = pageTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(async () => {
        // Store the page number for last copied button
        const pageSection = event.target.closest('.page-section');
        if (pageSection) {
          lastCopiedPageNum = parseInt(pageSection.dataset.page);
          await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
          lastCopiedBtn.classList.add('show');
        }
        showCopyFeedback(event.target);
      });
    }
    
    async function copyPageToNotes(event, pageKey, startIdx, endIdx, pageNum) {
      const pageTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        pageTexts.push(allParagraphs[i]);
      }
      
      const combinedText = pageTexts.join('\n\n');
      
      // Get the notes div for this page
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      if (notesDiv) {
        // Set the text content
        notesDiv.textContent = combinedText;
        
        // Save to database
        pageNotes[pageKey] = combinedText;
        await savePageNote(pageKey, combinedText);
        
        // Show saved indicator
        const savedIndicator = document.getElementById(`saved-${pageNum}`);
        if (savedIndicator) {
          savedIndicator.classList.add('show');
          setTimeout(() => {
            savedIndicator.classList.remove('show');
          }, 2000);
        }
        
        // Show feedback on button
        const button = event.target;
        const originalText = button.textContent;
        const originalBg = button.style.background;
        button.textContent = '‚úì Copied to Notes!';
        button.style.background = '#4CAF50';
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = originalBg;
        }, 2000);
      }
    }
    

    
    function showCopyFeedback(button) {
      const originalText = button.textContent;
      const originalBg = button.style.background;
      button.textContent = '‚úì Copied!';
      button.style.background = '#4CAF50';
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = originalBg;
      }, 2000);
    }
    
    async function copyParagraph(index) {
      const text = allParagraphs[index];
      navigator.clipboard.writeText(text).then(async () => {
        // Store the page number for last copied button
        const paraBtn = document.getElementById(`para-btn-${index}`);
        if (paraBtn) {
          const pageSection = paraBtn.closest('.page-section');
          if (pageSection) {
            lastCopiedPageNum = parseInt(pageSection.dataset.page);
            await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
            lastCopiedBtn.classList.add('show');
          }
        }
        
        const label = document.querySelector(`#para-btn-${index} label`);
        const originalText = label.textContent;
        label.textContent = '‚úì';
        setTimeout(() => {
          label.textContent = originalText;
        }, 1500);
      });
    }
    
    function copyAll() {
      const selectedTexts = [];
      
      // Check if any checkboxes are selected
      document.querySelectorAll('.para-checkbox:checked').forEach(checkbox => {
        const index = parseInt(checkbox.dataset.index);
        selectedTexts.push(allParagraphs[index]);
      });
      
      // If nothing selected, copy all
      const textToCopy = selectedTexts.length > 0 ? selectedTexts.join('\n\n') : allParagraphs.join('\n\n');
      const count = selectedTexts.length > 0 ? selectedTexts.length : allParagraphs.length;
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        const btn = copyAllBtn;
        const originalText = btn.textContent;
        btn.textContent = `‚úì Copied ${count}!`;
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      });
    }
    
    async function resetApp() {
      // Clear current file state
      if (db) {
        try {
          const transaction = db.transaction([notesStoreName], 'readwrite');
          const objectStore = transaction.objectStore(notesStoreName);
          objectStore.delete('_currentFileState');
        } catch (e) {
          console.error('Error clearing file state:', e);
        }
      }
      
      uploadSection.style.display = 'block';
      results.classList.remove('show');
      copyAllBtn.style.display = 'none';
      scrollTopBtn.classList.remove('show');
      lastCopiedBtn.classList.remove('show');
      fileInput.value = '';
      allParagraphs = [];
      lastCopiedPageNum = null;
      currentFileId = null;
      currentFileName = '';
      
      // Redirect to file manager
      window.location.href = 'upload.html';
    }
    
    // Scroll to top functionality
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // Scroll to last copied page
    function scrollToLastCopied() {
      if (lastCopiedPageNum !== null) {
        const pageSection = document.querySelector(`[data-page="${lastCopiedPageNum}"]`);
        if (pageSection) {
          pageSection.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
          // Highlight the page briefly
          pageSection.style.transition = 'background 0.5s';
          pageSection.style.background = '#fff3cd';
          setTimeout(() => {
            pageSection.style.background = '#f8f9ff';
          }, 1500);
        }
      }
    }
    
    // Show/hide scroll to top button based on scroll position
    // Also save scroll position for refresh persistence
    let scrollSaveTimeout;
    window.addEventListener('scroll', () => {
      if (window.pageYOffset > 300) {
        scrollTopBtn.classList.add('show');
      } else {
        scrollTopBtn.classList.remove('show');
      }
      
      // Debounce scroll position saving
      clearTimeout(scrollSaveTimeout);
      scrollSaveTimeout = setTimeout(async () => {
        if (currentFileId && currentFileName) {
          await saveCurrentFileState(currentFileId, currentFileName, window.pageYOffset);
        }
      }, 500);
    });
    
    // Go back to file manager
    function goBackToManager() {
      window.location.href = 'upload.html';
    }
    
    // Quotes and Meanings Storage
    const quotesStoreName = 'savedQuotes';
    const meaningsStoreName = 'savedMeanings';
    
    async function saveQuote(quote, source = '') {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([quotesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(quotesStoreName);
        const quoteData = {
          text: quote,
          source: source || currentFileName,
          date: new Date().toISOString(),
          timestamp: Date.now()
        };
        const request = objectStore.add(quoteData);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveMeaning(word, definition) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([meaningsStoreName], 'readwrite');
        const objectStore = transaction.objectStore(meaningsStoreName);
        const meaningData = {
          word: word,
          definition: definition,
          date: new Date().toISOString(),
          timestamp: Date.now()
        };
        const request = objectStore.add(meaningData);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getAllQuotes() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([quotesStoreName], 'readonly');
        const objectStore = transaction.objectStore(quotesStoreName);
        const request = objectStore.getAll();
        
        request.onsuccess = () => {
          const quotes = request.result.sort((a, b) => b.timestamp - a.timestamp);
          resolve(quotes);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getAllMeanings() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([meaningsStoreName], 'readonly');
        const objectStore = transaction.objectStore(meaningsStoreName);
        const request = objectStore.getAll();
        
        request.onsuccess = () => {
          const meanings = request.result.sort((a, b) => b.timestamp - a.timestamp);
          resolve(meanings);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function deleteQuote(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([quotesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(quotesStoreName);
        const request = objectStore.delete(id);
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function deleteMeaning(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([meaningsStoreName], 'readwrite');
        const objectStore = transaction.objectStore(meaningsStoreName);
        const request = objectStore.delete(id);
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    function openQuotesViewer() {
      window.open('quotes-viewer.html', '_blank');
    }
    
    // Theme toggle functionality
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      const themeToggle = document.getElementById('themeToggle');
      
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      // Update button icon
      themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Load saved theme on page load
    function loadTheme() {
      const savedTheme = localStorage.getItem('theme') || 'light';
      const html = document.documentElement;
      const themeToggle = document.getElementById('themeToggle');
      
      html.setAttribute('data-theme', savedTheme);
      if (themeToggle) {
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
    }
    
    // Initialize theme on load
    loadTheme();
    
    // Definition Popup Functionality
    let definitionPopup = null;
    let definitionPopupFullscreen = null;
    let currentSelectedWord = '';
    
    // Double-tap detection for mobile
    let lastTapTime = 0;
    let lastTapTarget = null;
    const DOUBLE_TAP_DELAY = 300; // milliseconds
    
    function initDefinitionPopup() {
      definitionPopup = document.getElementById('definitionPopup');
      definitionPopupFullscreen = document.getElementById('definitionPopupFullscreen');
      
      if (!definitionPopup || !definitionPopupFullscreen) {
        console.error('Definition popup elements not found');
        return;
      }
      
      console.log('Definition popups initialized');
      
      // Add selection listener to all notes displays
      document.addEventListener('mouseup', handleTextSelection, true);
      document.addEventListener('touchend', handleTextSelection, true);
      
      // Add double-tap listener for mobile
      document.addEventListener('touchend', handleDoubleTap, true);
      
      // Close popup when clicking outside
      document.addEventListener('click', (e) => {
        const clickedPopup = e.target.closest('.definition-popup');
        const clickedNotes = e.target.closest('.notes-display') || e.target.closest('.fullscreen-notes');
        
        if (!clickedPopup && !clickedNotes) {
          closeDefinitionPopup();
        }
      });
      
      console.log('Definition popup event listeners attached');
    }
    
    function handleDoubleTap(e) {
      const currentTime = new Date().getTime();
      const tapDelay = currentTime - lastTapTime;
      
      // Check if this is within notes area
      const target = e.target;
      const isNotesArea = target.classList?.contains('notes-display') || 
                          target.classList?.contains('fullscreen-notes') ||
                          target.closest('.notes-display') || 
                          target.closest('.fullscreen-notes');
      
      if (!isNotesArea) {
        lastTapTime = currentTime;
        return;
      }
      
      // Check if it's a double-tap on the same element
      if (tapDelay < DOUBLE_TAP_DELAY && tapDelay > 0 && lastTapTarget === target) {
        console.log('Double-tap detected');
        
        // Prevent default behavior
        e.preventDefault();
        
        // Add visual feedback
        const notesElement = target.closest('.notes-display') || target.closest('.fullscreen-notes');
        if (notesElement) {
          notesElement.classList.add('tap-feedback');
          setTimeout(() => {
            notesElement.classList.remove('tap-feedback');
          }, 300);
        }
        
        // Get the word at tap position
        const touch = e.changedTouches[0];
        const word = getWordAtPoint(touch.clientX, touch.clientY);
        
        if (word && word.length >= 2) {
          console.log('Word from double-tap:', word);
          
          // Create a fake rect for the tapped position
          const rect = {
            left: touch.clientX - 50,
            right: touch.clientX + 50,
            top: touch.clientY - 20,
            bottom: touch.clientY + 20,
            width: 100,
            height: 40
          };
          
          showDefinitionPopup(word, rect);
        }
        
        // Reset tap tracking
        lastTapTime = 0;
        lastTapTarget = null;
      } else {
        // Record this tap
        lastTapTime = currentTime;
        lastTapTarget = target;
      }
    }
    
    function getWordAtPoint(x, y) {
      // Get the element at the point
      const element = document.elementFromPoint(x, y);
      if (!element) return null;
      
      // Check if it's in notes area
      const isNotesArea = element.classList?.contains('notes-display') || 
                          element.classList?.contains('fullscreen-notes') ||
                          element.closest('.notes-display') || 
                          element.closest('.fullscreen-notes');
      
      if (!isNotesArea) return null;
      
      // Try to get text node at position
      let range, textNode, offset;
      
      if (document.caretPositionFromPoint) {
        // Standard
        range = document.caretPositionFromPoint(x, y);
        if (range) {
          textNode = range.offsetNode;
          offset = range.offset;
        }
      } else if (document.caretRangeFromPoint) {
        // WebKit
        range = document.caretRangeFromPoint(x, y);
        if (range) {
          textNode = range.startContainer;
          offset = range.startOffset;
        }
      }
      
      if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
        // Fallback: try to get text from element
        const text = element.textContent || '';
        const words = text.split(/\s+/);
        if (words.length > 0) {
          // Return first word as fallback
          return words[0].replace(/[^\w\s'-]/g, '').toLowerCase();
        }
        return null;
      }
      
      // Get the full text
      const text = textNode.textContent;
      
      // Find word boundaries around the offset
      let start = offset;
      let end = offset;
      
      // Move start backward to word boundary
      while (start > 0 && /[\w'-]/.test(text[start - 1])) {
        start--;
      }
      
      // Move end forward to word boundary
      while (end < text.length && /[\w'-]/.test(text[end])) {
        end++;
      }
      
      // Extract the word
      const word = text.substring(start, end).trim();
      
      // Clean and return
      return word.replace(/[^\w\s'-]/g, '').toLowerCase();
    }
    
    function handleTextSelection(e) {
      const selection = window.getSelection();
      const selectedText = selection.toString().trim();
      
      console.log('Text selection event:', {
        selectedText,
        target: e.target?.className,
        anchorNode: selection.anchorNode
      });
      
      if (!selectedText || selectedText.length === 0) {
        return;
      }
      
      // Check if selection is within notes area
      // Check both the event target and the selection's anchor node
      let isNotesArea = false;
      
      if (e.target) {
        const target = e.target;
        isNotesArea = target.classList?.contains('notes-display') || 
                      target.classList?.contains('fullscreen-notes') ||
                      target.closest('.notes-display') || 
                      target.closest('.fullscreen-notes');
      }
      
      // Also check the selection's anchor node
      if (!isNotesArea && selection.anchorNode) {
        const anchorElement = selection.anchorNode.nodeType === Node.TEXT_NODE 
          ? selection.anchorNode.parentElement 
          : selection.anchorNode;
        
        if (anchorElement) {
          isNotesArea = anchorElement.classList?.contains('notes-display') || 
                        anchorElement.classList?.contains('fullscreen-notes') ||
                        anchorElement.closest('.notes-display') || 
                        anchorElement.closest('.fullscreen-notes');
        }
      }
      
      console.log('Is notes area:', isNotesArea);
      
      if (!isNotesArea) {
        return;
      }
      
      // Get selection position
      if (selection.rangeCount === 0) {
        return;
      }
      
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      
      // Check if it's a single word or multiple words
      const words = selectedText.split(/\s+/);
      
      if (words.length === 1) {
        // Single word - show definition
        const word = selectedText.replace(/[^\w\s'-]/g, '').toLowerCase();
        
        if (word.length < 2) {
          return;
        }
        
        showDefinitionPopup(word, rect);
      } else {
        // Multiple words - auto-save after 5 seconds
        startQuoteAutoSave(selectedText);
      }
    }
    
    let quoteAutoSaveTimeout = null;
    let lastSelectedQuote = '';
    
    function startQuoteAutoSave(quote) {
      // Clear any existing timeout
      if (quoteAutoSaveTimeout) {
        clearTimeout(quoteAutoSaveTimeout);
      }
      
      lastSelectedQuote = quote;
      
      // Set new timeout for 5 seconds
      quoteAutoSaveTimeout = setTimeout(async () => {
        // Check if selection is still active
        const currentSelection = window.getSelection().toString().trim();
        
        if (currentSelection === lastSelectedQuote) {
          try {
            await saveQuote(lastSelectedQuote);
            console.log('Quote auto-saved:', lastSelectedQuote);
            
            // Show brief notification
            showQuoteSavedNotification();
          } catch (error) {
            console.error('Error auto-saving quote:', error);
          }
        }
      }, 5000);
    }
    
    function showQuoteSavedNotification() {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: #4CAF50;
        color: white;
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        z-index: 10000;
        animation: slideUp 0.3s ease;
      `;
      notification.textContent = '‚úì Quote saved to library';
      
      document.body.appendChild(notification);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'slideDown 0.3s ease';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }
    
    function showDefinitionPopup(word, rect) {
      currentSelectedWord = word;
      
      // Check if we're in fullscreen mode
      const fullscreenModal = document.getElementById('fullscreenModal');
      const isFullscreen = fullscreenModal && fullscreenModal.classList.contains('show');
      
      // Choose the correct popup
      const activePopup = isFullscreen ? definitionPopupFullscreen : definitionPopup;
      const wordElement = isFullscreen ? document.getElementById('definitionWordFullscreen') : document.getElementById('definitionWord');
      const contentElement = isFullscreen ? document.getElementById('definitionContentFullscreen') : document.getElementById('definitionContent');
      
      if (!activePopup) {
        console.error('Active popup not found');
        return;
      }
      
      console.log('Showing definition popup:', { word, isFullscreen });
      
      // Position popup
      const popupWidth = 350;
      const popupHeight = 200; // estimated
      
      let left = rect.left + (rect.width / 2) - (popupWidth / 2);
      let top = rect.top - popupHeight - 10;
      
      // Adjust if popup goes off screen
      if (left < 10) left = 10;
      if (left + popupWidth > window.innerWidth - 10) {
        left = window.innerWidth - popupWidth - 10;
      }
      
      // If popup goes above viewport, show below selection
      if (top < 10) {
        top = rect.bottom + 10;
      }
      
      // Always use fixed positioning
      activePopup.style.position = 'fixed';
      activePopup.style.left = left + 'px';
      activePopup.style.top = top + 'px';
      
      // Update word in header
      wordElement.textContent = word;
      
      // Show loading state
      contentElement.innerHTML = `
        <div class="definition-loading">
          <div class="definition-spinner"></div>
          <div>Loading definition...</div>
        </div>
      `;
      
      activePopup.classList.add('show');
      
      // Fetch definition
      fetchDefinition(word, isFullscreen);
    }
    
    async function fetchDefinition(word, isFullscreen = false) {
      try {
        // Check if API key is set
        if (!MERRIAM_WEBSTER_API_KEY || MERRIAM_WEBSTER_API_KEY === 'YOUR_API_KEY_HERE') {
          displayDefinitionError('‚ö†Ô∏è API key not configured. Please add your Merriam-Webster API key in the code.', isFullscreen);
          return;
        }
        
        // Using Merriam-Webster Dictionary API
        const url = `https://dictionaryapi.com/api/v3/references/${MERRIAM_WEBSTER_DICTIONARY}/json/${encodeURIComponent(word)}?key=${MERRIAM_WEBSTER_API_KEY}`;
        console.log('Fetching definition from:', url.replace(MERRIAM_WEBSTER_API_KEY, 'API_KEY_HIDDEN'));
        
        const response = await fetch(url);
        
        console.log('Response status:', response.status);
        
        if (!response.ok) {
          if (response.status === 403) {
            throw new Error('Invalid API key. Please check your Merriam-Webster API key.');
          } else if (response.status === 404) {
            throw new Error('Word not found in dictionary.');
          } else {
            throw new Error(`API error: ${response.status}`);
          }
        }
        
        const data = await response.json();
        console.log('API response data:', data);
        
        // Check if we got suggestions instead of definitions
        if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'string') {
          displayDefinitionError(`Did you mean: <strong>${data.slice(0, 5).join(', ')}</strong>?`, isFullscreen);
          return;
        }
        
        if (!data || data.length === 0) {
          throw new Error('Word not found in dictionary.');
        }
        
        displayMerriamWebsterDefinition(data[0], word, isFullscreen);
      } catch (error) {
        console.error('Definition fetch error:', error);
        displayDefinitionError(error.message, isFullscreen);
      }
    }
    
    function displayMerriamWebsterDefinition(data, word, isFullscreen = false) {
      const contentDiv = isFullscreen ? document.getElementById('definitionContentFullscreen') : document.getElementById('definitionContent');
      
      let html = '';
      
      // Get pronunciation
      let audioUrl = null;
      let phoneticText = '';
      
      if (data.hwi && data.hwi.prs && data.hwi.prs.length > 0) {
        const pr = data.hwi.prs[0];
        if (pr.mw) {
          phoneticText = pr.mw;
        }
        if (pr.sound && pr.sound.audio) {
          // Merriam-Webster audio URL format
          const audioFile = pr.sound.audio;
          const subdir = audioFile.startsWith('bix') ? 'bix' :
                        audioFile.startsWith('gg') ? 'gg' :
                        audioFile.match(/^[0-9]/) ? 'number' :
                        audioFile.charAt(0);
          audioUrl = `https://media.merriam-webster.com/audio/prons/en/us/mp3/${subdir}/${audioFile}.mp3`;
        }
      }
      
      // Add phonetic if available
      if (phoneticText || audioUrl) {
        if (audioUrl) {
          html += `<div class="definition-phonetic" style="cursor: pointer;" onclick="playDefinitionAudio('${audioUrl.replace(/'/g, "\\'")}', event)" title="Click to hear pronunciation">üîä ${phoneticText}</div>`;
        } else {
          html += `<div class="definition-phonetic">üîä ${phoneticText}</div>`;
        }
      }
      
      // Get functional label (part of speech)
      const partOfSpeech = data.fl || '';
      
      // Add meanings
      if (data.shortdef && data.shortdef.length > 0) {
        html += `<div class="definition-meaning">`;
        if (partOfSpeech) {
          html += `<div class="definition-pos">${partOfSpeech}</div>`;
        }
        
        data.shortdef.slice(0, 3).forEach((def, index) => {
          html += `<div class="definition-text">${index + 1}. ${def}</div>`;
        });
        
        html += `</div>`;
      } else if (data.def && data.def.length > 0) {
        // Fallback to detailed definitions
        html += `<div class="definition-meaning">`;
        if (partOfSpeech) {
          html += `<div class="definition-pos">${partOfSpeech}</div>`;
        }
        
        const sseq = data.def[0].sseq;
        if (sseq && sseq.length > 0) {
          let defCount = 0;
          for (const sense of sseq) {
            if (defCount >= 3) break;
            if (sense[0] && sense[0][1] && sense[0][1].dt) {
              const dt = sense[0][1].dt;
              for (const item of dt) {
                if (item[0] === 'text') {
                  const text = item[1].replace(/\{[^}]+\}/g, ''); // Remove markup
                  html += `<div class="definition-text">${defCount + 1}. ${text}</div>`;
                  defCount++;
                  break;
                }
              }
            }
          }
        }
        
        html += `</div>`;
      }
      
      if (!html || html.indexOf('definition-text') === -1) {
        html = '<div class="definition-error">No definition found</div>';
      } else {
        // Add save button
        html += `<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
          <button class="notes-btn" onclick="saveCurrentMeaning('${word.replace(/'/g, "\\'")}', event)" style="width: 100%; justify-content: center;">
            üíæ Save to Library
          </button>
        </div>`;
        
        // Auto-save the meaning
        const definitionText = data.shortdef ? data.shortdef.join('; ') : 'Definition available';
        saveMeaning(word, definitionText).catch(err => console.error('Error auto-saving meaning:', err));
      }
      
      contentDiv.innerHTML = html;
    }
    
    async function saveCurrentMeaning(word, event) {
      if (event) event.stopPropagation();
      
      try {
        // Get the definition text from the popup
        const contentDiv = document.querySelector('.definition-popup.show .definition-content');
        const defTexts = contentDiv.querySelectorAll('.definition-text');
        const definition = Array.from(defTexts).map(el => el.textContent).join(' ');
        
        await saveMeaning(word, definition);
        
        // Show feedback
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = '‚úì Saved!';
        btn.style.background = '#4CAF50';
        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.style.background = '';
        }, 2000);
      } catch (error) {
        console.error('Error saving meaning:', error);
        alert('Failed to save meaning');
      }
    }
    
    function displayDefinitionError(message, isFullscreen = false) {
      const contentDiv = isFullscreen ? document.getElementById('definitionContentFullscreen') : document.getElementById('definitionContent');
      contentDiv.innerHTML = `
        <div class="definition-error">
          ${message}
        </div>
      `;
    }
    
    function closeDefinitionPopup() {
      if (definitionPopup) {
        definitionPopup.classList.remove('show');
      }
      if (definitionPopupFullscreen) {
        definitionPopupFullscreen.classList.remove('show');
      }
    }
    
    // Play pronunciation audio
    let currentDefinitionAudio = null;
    
    function playDefinitionAudio(audioUrl, event) {
      if (event) {
        event.stopPropagation();
      }
      
      console.log('Playing audio:', audioUrl);
      
      // Stop any currently playing audio
      if (currentDefinitionAudio) {
        currentDefinitionAudio.pause();
        currentDefinitionAudio.currentTime = 0;
      }
      
      // Create and play new audio
      currentDefinitionAudio = new Audio(audioUrl);
      
      currentDefinitionAudio.onerror = (e) => {
        console.error('Audio playback error:', e);
        alert('Failed to play pronunciation audio');
      };
      
      currentDefinitionAudio.play().catch(error => {
        console.error('Audio play error:', error);
        alert('Failed to play pronunciation audio');
      });
    }
    

    
    // Initialize definition popup when page loads
    window.addEventListener('load', () => {
      setTimeout(initDefinitionPopup, 500);
    });
    
    // Search functionality
    let searchTimeout;
    let searchAbortController = null;
    
    function searchParagraphs() {
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const searchLoading = document.getElementById('searchLoading');
      const query = searchInput.value.trim().toLowerCase();
      
      // Cancel previous search
      if (searchAbortController) {
        searchAbortController.abort();
      }
      
      // Clear previous timeout
      clearTimeout(searchTimeout);
      
      if (!query) {
        searchResults.classList.remove('show');
        searchLoading.classList.remove('show');
        clearSearchHighlights();
        return;
      }
      
      // Show loading
      searchLoading.classList.add('show');
      
      // Debounce search for better performance
      searchTimeout = setTimeout(() => {
        performSearch(query, searchResults, searchLoading);
      }, 300);
    }
    
    function performSearch(query, searchResults, searchLoading) {
      // Create abort controller for this search
      searchAbortController = new AbortController();
      
      try {
        // Search through all paragraphs
        const matches = [];
        allParagraphs.forEach((para, index) => {
          // Check if search was cancelled
          if (searchAbortController.signal.aborted) {
            throw new Error('Search cancelled');
          }
          
          if (para.toLowerCase().includes(query)) {
            matches.push({
              index: index,
              text: para,
              pageNum: getPageNumberForParagraph(index)
            });
          }
        });
        
        // Hide loading
        searchLoading.classList.remove('show');
        
        // Display results
        if (matches.length > 0) {
          const matchesByPage = {};
          matches.forEach(match => {
            if (!matchesByPage[match.pageNum]) {
              matchesByPage[match.pageNum] = [];
            }
            matchesByPage[match.pageNum].push(match.index);
          });
          
          let resultsHTML = `
            <div class="search-results-title">
              Found in ${matches.length} paragraph(s) across ${Object.keys(matchesByPage).length} page(s):
            </div>
            <div class="search-matches">
          `;
          
          Object.keys(matchesByPage).sort((a, b) => parseInt(a) - parseInt(b)).forEach(pageNum => {
            const paraNumbers = matchesByPage[pageNum];
            resultsHTML += `
              <div class="search-match-item" onclick="scrollToParagraph(${paraNumbers[0]})">
                Page ${pageNum} (${paraNumbers.length} match${paraNumbers.length > 1 ? 'es' : ''})
              </div>
            `;
          });
          
          resultsHTML += '</div>';
          searchResults.innerHTML = resultsHTML;
          searchResults.classList.add('show');
          
          // Highlight matching paragraphs
          highlightSearchMatches(matches.map(m => m.index));
        } else {
          searchResults.innerHTML = '<div class="search-no-results">No matches found</div>';
          searchResults.classList.add('show');
          clearSearchHighlights();
        }
      } catch (error) {
        if (error.message === 'Search cancelled') {
          console.log('Search was cancelled');
        } else {
          console.error('Search error:', error);
        }
        searchLoading.classList.remove('show');
      }
    }
    
    function getPageNumberForParagraph(paraIndex) {
      let count = 0;
      const pageSections = document.querySelectorAll('.page-section');
      
      for (let section of pageSections) {
        const pageNum = parseInt(section.dataset.page);
        const parasInPage = section.querySelectorAll('.paragraph-item').length;
        
        if (paraIndex < count + parasInPage) {
          return pageNum;
        }
        count += parasInPage;
      }
      return 1;
    }
    
    function highlightSearchMatches(indices) {
      clearSearchHighlights();
      
      indices.forEach(index => {
        const paraBtn = document.getElementById(`para-btn-${index}`);
        if (paraBtn) {
          paraBtn.classList.add('search-highlight');
        }
      });
    }
    
    function clearSearchHighlights() {
      document.querySelectorAll('.paragraph-item.search-highlight').forEach(item => {
        item.classList.remove('search-highlight');
      });
    }
    
    function scrollToParagraph(paraIndex) {
      const paraBtn = document.getElementById(`para-btn-${paraIndex}`);
      if (paraBtn) {
        paraBtn.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
        
        // Flash animation
        paraBtn.classList.remove('search-highlight');
        setTimeout(() => {
          paraBtn.classList.add('search-highlight');
        }, 10);
      }
    }
    
    function clearSearch() {
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      const searchLoading = document.getElementById('searchLoading');
      
      // Cancel ongoing search
      if (searchAbortController) {
        searchAbortController.abort();
        searchAbortController = null;
      }
      
      // Clear timeout
      clearTimeout(searchTimeout);
      
      searchInput.value = '';
      searchResults.classList.remove('show');
      searchLoading.classList.remove('show');
      clearSearchHighlights();
    }
    
    // Fullscreen notes functionality
    let currentFullscreenPageKey = null;
    let currentFullscreenPageNum = null;
    
    function openFullscreenNotes(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const modal = document.getElementById('fullscreenModal');
      const fullscreenContent = document.getElementById('fullscreenNotesContent');
      const fullscreenTitle = document.getElementById('fullscreenTitle');
      
      if (!notesDiv || !modal || !fullscreenContent) return;
      
      // Store current page info
      currentFullscreenPageKey = pageKey;
      currentFullscreenPageNum = pageNum;
      
      // Copy content to fullscreen (preserve HTML if speech is active)
      if (currentSpeakingPage === pageNum && originalText) {
        // Speech is active, copy HTML to preserve highlighting
        fullscreenContent.innerHTML = notesDiv.innerHTML;
      } else {
        fullscreenContent.textContent = notesDiv.textContent;
      }
      
      fullscreenTitle.textContent = `Notes - Page ${pageNum}`;
      
      // Show modal
      modal.classList.add('show');
      
      // Request true fullscreen
      if (modal.requestFullscreen) {
        modal.requestFullscreen().catch(err => {
          console.log('Fullscreen request failed:', err);
        });
      } else if (modal.webkitRequestFullscreen) {
        modal.webkitRequestFullscreen();
      } else if (modal.mozRequestFullScreen) {
        modal.mozRequestFullScreen();
      } else if (modal.msRequestFullscreen) {
        modal.msRequestFullscreen();
      }
      
      // Focus on content
      setTimeout(() => {
        fullscreenContent.focus();
        
        // Add direct event listeners to fullscreen notes
        fullscreenContent.addEventListener('mouseup', handleTextSelection, true);
        fullscreenContent.addEventListener('touchend', handleTextSelection, true);
        
        console.log('Fullscreen notes event listeners attached');
      }, 100);
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }
    
    function closeFullscreenNotes() {
      const modal = document.getElementById('fullscreenModal');
      const fullscreenContent = document.getElementById('fullscreenNotesContent');
      
      if (!modal || !fullscreenContent) return;
      
      // Close definition popup if open
      closeDefinitionPopup();
      
      // Exit fullscreen mode
      if (document.fullscreenElement || document.webkitFullscreenElement || 
          document.mozFullScreenElement || document.msFullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
      
      // Notes are read-only, no need to save changes
      
      // Hide modal
      modal.classList.remove('show');
      
      // Restore body scroll
      document.body.style.overflow = '';
      
      // Clear current page info
      currentFullscreenPageKey = null;
      currentFullscreenPageNum = null;
    }
    
    // Notes are now read-only, no need for handleFullscreenNoteChange function
    
    // Close fullscreen with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const modal = document.getElementById('fullscreenModal');
        if (modal && modal.classList.contains('show')) {
          closeFullscreenNotes();
        }
      }
    });
    
    // Handle fullscreen change events (when user exits fullscreen via browser controls)
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
    
    function handleFullscreenChange() {
      const modal = document.getElementById('fullscreenModal');
      
      // If we exited fullscreen but modal is still showing, close it
      if (modal && modal.classList.contains('show')) {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && !document.msFullscreenElement) {
          closeFullscreenNotes();
        }
      }
    }
  </script>
</body>
</html>
