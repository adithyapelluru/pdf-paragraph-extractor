<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Paragraph Extractor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 1200px;
      width: 100%;
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    .header p {
      opacity: 0.9;
      font-size: 16px;
    }
    
    .upload-section {
      padding: 40px;
      text-align: center;
    }
    
    .upload-box {
      border: 3px dashed #667eea;
      border-radius: 15px;
      padding: 60px 40px;
      background: #f8f9ff;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-box:hover {
      background: #f0f2ff;
      border-color: #764ba2;
    }
    
    .upload-box.dragover {
      background: #e8ebff;
      border-color: #764ba2;
      transform: scale(1.02);
    }
    
    .upload-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    
    .upload-text {
      font-size: 20px;
      color: #333;
      margin-bottom: 10px;
    }
    
    .upload-hint {
      color: #666;
      font-size: 14px;
    }
    
    .file-input {
      display: none;
    }
    
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    .results {
      padding: 40px;
      display: none;
    }
    
    .results.show {
      display: block;
    }
    
    .file-info {
      background: #f8f9ff;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .page-section {
      margin-bottom: 30px;
      background: #f8f9ff;
      padding: 20px;
      border-radius: 15px;
    }
    
    .page-header {
      font-size: 20px;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .paragraphs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }
    
    .paragraph-item {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .paragraph-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }
    
    .paragraph-item.selected {
      background: #FF9800;
    }
    
    .paragraph-item.copied {
      background: #4CAF50;
    }
    
    .para-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    
    .paragraph-item label {
      cursor: pointer;
      user-select: none;
    }
    
    .page-actions {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: flex-start;
    }
    
    .page-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    .page-btn:hover {
      background: #764ba2;
    }
    
    .page-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .page-notes {
      margin-top: 15px;
      padding: 15px;
      background: white;
      border-radius: 10px;
      border: 2px solid #667eea;
    }
    
    .notes-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .notes-title {
      font-weight: bold;
      color: #667eea;
      font-size: 16px;
    }
    
    .notes-textarea {
      width: 100%;
      min-height: 80px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      transition: border-color 0.3s;
      display: none;
    }
    
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .notes-display {
      width: 100%;
      min-height: 80px;
      height: 120px;
      max-height: 400px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: white;
      overflow-y: auto;
      scroll-behavior: smooth;
      resize: vertical;
    }
    
    .notes-display.editable {
      cursor: text;
    }
    
    .notes-display:empty:before {
      content: attr(data-placeholder);
      color: #999;
    }
    
    .highlight-word {
      background: #FFD700;
      color: #000;
      padding: 2px 0;
      border-radius: 3px;
      animation: highlight-pulse 0.3s ease;
    }
    
    @keyframes highlight-pulse {
      0% { background: #FFD700; }
      50% { background: #FFA500; }
      100% { background: #FFD700; }
    }
    
    .notes-saved {
      color: #4CAF50;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .notes-saved.show {
      opacity: 1;
    }
    
    .notes-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .notes-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }
    
    .notes-btn:hover {
      background: #764ba2;
      transform: translateY(-1px);
    }
    
    .notes-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    .notes-btn.speaking {
      background: #FF9800;
      animation: pulse 1.5s infinite;
    }
    
    .notes-btn.paused {
      background: #FFA726;
    }
    
    .notes-btn.stop {
      background: #f44336;
    }
    
    .notes-btn.stop:hover {
      background: #d32f2f;
    }
    
    .notes-btn.font-control {
      background: #9C27B0;
      min-width: 32px;
      padding: 6px 8px;
    }
    
    .notes-btn.font-control:hover {
      background: #7B1FA2;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .font-size-controls {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    
    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: #f0f2ff;
      border-radius: 8px;
    }
    
    .speed-label {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 80px;
    }
    
    .speed-slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }
    
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .speed-slider::-webkit-slider-thumb:hover {
      background: #764ba2;
    }
    
    .speed-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
      transition: background 0.3s;
    }
    
    .speed-slider::-moz-range-thumb:hover {
      background: #764ba2;
    }
    
    .speed-value {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 35px;
      text-align: right;
    }
    
    .floating-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: #4CAF50;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
      transition: all 0.3s;
      z-index: 1000;
    }
    
    .floating-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.5);
    }
    
    .scroll-top-btn {
      position: fixed;
      bottom: 100px;
      right: 30px;
      background: #667eea;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: none;
    }
    
    .scroll-top-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      background: #764ba2;
    }
    
    .scroll-top-btn.show {
      display: block;
    }
    
    .last-copied-btn {
      position: fixed;
      bottom: 165px;
      right: 30px;
      background: #FF9800;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(255, 152, 0, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: none;
    }
    
    .last-copied-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(255, 152, 0, 0.5);
      background: #F57C00;
    }
    
    .last-copied-btn.show {
      display: block;
    }
    
    .back-floating-btn {
      position: fixed;
      top: 30px;
      left: 30px;
      background: #666;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .back-floating-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      background: #555;
    }
    
    .back-btn {
      background: #666;
      margin-right: 10px;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      display: none;
    }
    
    .loading.show {
      display: block;
    }
    
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .header h1 {
        font-size: 24px;
      }
      
      .header p {
        font-size: 14px;
      }
      
      .upload-section, .results {
        padding: 20px;
      }
      
      .upload-box {
        padding: 30px 20px;
      }
      
      .upload-icon {
        font-size: 48px;
      }
      
      .upload-text {
        font-size: 18px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      .file-info {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      .page-section {
        padding: 15px;
      }
      
      .page-header {
        font-size: 18px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 8px;
      }
      
      .paragraph-item {
        padding: 10px;
        font-size: 14px;
      }
      
      .para-checkbox {
        width: 16px;
        height: 16px;
      }
      
      .page-actions {
        flex-wrap: wrap;
      }
      
      .page-btn {
        font-size: 12px;
        padding: 6px 12px;
      }
      
      .notes-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .notes-actions {
        width: 100%;
        justify-content: flex-start;
      }
      
      .notes-display {
        min-height: 80px;
        height: 100px;
        font-size: 13px;
      }
      
      .speed-control {
        flex-direction: column;
        align-items: stretch;
      }
      
      .speed-label {
        min-width: auto;
      }
      
      .floating-btn {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 14px;
      }
      
      .scroll-top-btn {
        bottom: 80px;
        right: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .last-copied-btn {
        bottom: 135px;
        right: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      .back-floating-btn {
        top: 15px;
        left: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
    }
    
    @media (max-width: 480px) {
      .header h1 {
        font-size: 20px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }
      
      .paragraph-item {
        padding: 8px;
        font-size: 12px;
      }
      
      .page-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .notes-title {
        font-size: 14px;
      }
      
      .notes-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .floating-btn {
        padding: 10px 15px;
        font-size: 12px;
      }
      
      .scroll-top-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .last-copied-btn {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .back-floating-btn {
        top: 10px;
        left: 10px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìÑ PDF & EPUB Paragraph Extractor</h1>
      <p>Upload a PDF or EPUB and copy paragraphs with ease</p>
      <p style="margin-top: 10px;"><a href="index.html" style="color: white; text-decoration: underline;">Go to File Manager</a></p>
    </div>
    
    <div class="upload-section" id="uploadSection" style="display: none;">
      <div class="upload-box" id="uploadBox">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Redirecting to File Manager...</div>
      </div>
    </div>
    
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>Extracting paragraphs...</p>
    </div>
    
    <div class="results" id="results">
      <div class="file-info">
        <div>
          <strong>File:</strong> <span id="fileName"></span><br>
          <strong>Paragraphs:</strong> <span id="paraCount"></span>
        </div>
        <button class="btn back-btn" onclick="resetApp()">Upload Another</button>
      </div>
      <div id="paragraphsContainer"></div>
    </div>
  </div>
  
  <button class="floating-btn" id="copyAllBtn" style="display: none;" onclick="copyAll()">
    üìã Copy All
  </button>
  
  <button class="scroll-top-btn" id="scrollTopBtn" onclick="scrollToTop()" title="Scroll to top">
    ‚¨ÜÔ∏è
  </button>
  
  <button class="last-copied-btn" id="lastCopiedBtn" onclick="scrollToLastCopied()" title="Go to last copied page">
    üìç
  </button>
  
  <button class="back-floating-btn" onclick="goBackToManager()" title="Back to File Manager">
    ‚¨ÖÔ∏è
  </button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allParagraphs = [];
    let db;
    let lastCopiedPageNum = null;
    let currentFileName = '';
    let currentFileId = null;
    let scrollRestorePosition = 0;
    
    const uploadBox = document.getElementById('uploadBox');
    const fileInput = document.getElementById('fileInput');
    const uploadSection = document.getElementById('uploadSection');
    const loading = document.getElementById('loading');
    const results = document.getElementById('results');
    const copyAllBtn = document.getElementById('copyAllBtn');
    const scrollTopBtn = document.getElementById('scrollTopBtn');
    const lastCopiedBtn = document.getElementById('lastCopiedBtn');
    
    // IndexedDB setup
    const dbName = 'FileExtractorDB';
    const storeName = 'files';
    const notesStoreName = 'pageNotes';
    let pageNotes = {};
    
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 2);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains(notesStoreName)) {
            db.createObjectStore(notesStoreName, { keyPath: 'pageKey' });
          }
        };
      });
    }
    
    async function savePageNote(pageKey, note) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.put({ pageKey, note });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadPageNotes() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.getAll();
        
        request.onsuccess = () => {
          const notes = {};
          request.result.forEach(item => {
            notes[item.pageKey] = item.note;
          });
          resolve(notes);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveLastCopiedPage(fileName, pageNum) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = `${fileName}_lastCopied`;
        const request = objectStore.put({ pageKey, note: pageNum.toString() });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveCurrentFileState(fileId, fileName, scrollPosition) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = '_currentFileState';
        const request = objectStore.put({ 
          pageKey, 
          note: JSON.stringify({ fileId, fileName, scrollPosition, timestamp: Date.now() })
        });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadCurrentFileState() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = '_currentFileState';
        const request = objectStore.get(pageKey);
        
        request.onsuccess = () => {
          if (request.result && request.result.note) {
            try {
              resolve(JSON.parse(request.result.note));
            } catch (e) {
              resolve(null);
            }
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadLastCopiedPage(fileName) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const pageKey = `${fileName}_lastCopied`;
        const request = objectStore.get(pageKey);
        
        request.onsuccess = () => {
          if (request.result && request.result.note) {
            resolve(parseInt(request.result.note));
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getFileById(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([storeName], 'readonly');
        const objectStore = transaction.objectStore(storeName);
        const request = objectStore.get(id);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Preload speech voices (important for mobile)
    if ('speechSynthesis' in window) {
      // Trigger voice loading
      window.speechSynthesis.getVoices();
      window.speechSynthesis.addEventListener('voiceschanged', () => {
        console.log('Voices loaded:', window.speechSynthesis.getVoices().length);
      });
    }
    
    // Check if file was selected from upload page or restore from state
    window.addEventListener('load', async () => {
      await initDB();
      pageNotes = await loadPageNotes();
      
      // Check for new file from upload page
      let fileIdToLoad = localStorage.getItem('currentFileId');
      
      if (fileIdToLoad) {
        // New file selected from upload page
        localStorage.removeItem('currentFileId');
        currentFileId = parseInt(fileIdToLoad);
      } else {
        // Try to restore previous state (refresh scenario)
        const savedState = await loadCurrentFileState();
        if (savedState && savedState.fileId) {
          currentFileId = savedState.fileId;
          scrollRestorePosition = savedState.scrollPosition || 0;
        }
      }
      
      if (currentFileId) {
        const fileData = await getFileById(currentFileId);
        
        if (fileData) {
          // Convert data URL back to file
          fetch(fileData.data)
            .then(res => res.blob())
            .then(blob => {
              const newFile = new File([blob], fileData.name, { type: blob.type });
              processFile(newFile);
            });
        } else {
          // File not found, redirect to file manager
          window.location.href = 'upload.html';
        }
      } else {
        // No file selected, redirect to file manager
        window.location.href = 'upload.html';
      }
    });
    
    // Disable drag and drop and file input on extractor page
    // Users should upload from the file manager page only
    
    async function processFile(file) {
      if (file.name.endsWith('.epub')) {
        await processEPUB(file);
      } else {
        await processPDF(file);
      }
    }
    
    async function processEPUB(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const JSZip = window.JSZip || await loadJSZip();
        const zip = await JSZip.loadAsync(file);
        
        // Find all HTML/XHTML files in the EPUB
        const htmlFiles = Object.keys(zip.files).filter(name => 
          name.match(/\.(html|xhtml|htm)$/i) && !name.startsWith('__MACOSX')
        );
        
        const pageData = [];
        let pageNum = 1;
        
        for (const fileName of htmlFiles) {
          const content = await zip.files[fileName].async('text');
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          
          // Remove script and style tags
          doc.querySelectorAll('script, style').forEach(el => el.remove());
          
          // Extract paragraphs from the HTML
          const paragraphs = [];
          const textElements = doc.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
          
          textElements.forEach(el => {
            const text = el.textContent.trim();
            if (text.length > 30) {
              paragraphs.push(text);
            }
          });
          
          if (paragraphs.length > 0) {
            pageData.push({
              pageNum: pageNum++,
              paragraphs: paragraphs
            });
          }
        }
        
        if (pageData.length === 0) {
          throw new Error('No readable content found in EPUB');
        }
        
        // Flatten for allParagraphs array
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        
        displayResults(file.name, pageData);
      } catch (error) {
        alert('Error processing EPUB: ' + error.message);
        resetApp();
      }
    }
    
    async function loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    async function processPDF(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        const pageData = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          
          // Group text items by line
          const lines = [];
          let currentLine = { items: [], y: null };
          
          textContent.items.forEach(item => {
            const y = Math.round(item.transform[5]);
            
            // If this is a new line
            if (currentLine.y === null || Math.abs(currentLine.y - y) > 5) {
              if (currentLine.items.length > 0) {
                lines.push(currentLine);
              }
              currentLine = { items: [item], y: y };
            } else {
              // Same line, add to current line
              currentLine.items.push(item);
            }
          });
          
          // Add the last line
          if (currentLine.items.length > 0) {
            lines.push(currentLine);
          }
          
          // Sort lines by Y position (top to bottom)
          lines.sort((a, b) => b.y - a.y);
          
          // Build paragraphs from lines
          const paragraphs = [];
          let currentParagraph = '';
          let lastLineY = null;
          
          lines.forEach(line => {
            // Sort items in line by X position (left to right)
            line.items.sort((a, b) => a.transform[4] - b.transform[4]);
            
            // Combine items in line to form text
            const lineText = line.items.map(item => item.str).join(' ');
            
            // Check if this is a new paragraph
            // Paragraph break if:
            // 1. Large vertical gap (more than 1.5x typical line height)
            // 2. The line is indented (first line of paragraph)
            // 3. The previous line ended with a sentence terminator
            
            const isLargeGap = lastLineY !== null && (lastLineY - line.y) > 20;
            const isIndented = line.items[0]?.transform[4] > 50;
            const prevEndsWithTerminator = /[.!?]\s*$/.test(currentParagraph);
            
            if (currentParagraph && (isLargeGap || (isIndented && prevEndsWithTerminator))) {
              paragraphs.push(currentParagraph.trim());
              currentParagraph = lineText;
            } else {
              // Continue current paragraph
              currentParagraph += (currentParagraph ? ' ' : '') + lineText;
            }
            
            lastLineY = line.y;
          });
          
          // Add the last paragraph
          if (currentParagraph.trim()) {
            paragraphs.push(currentParagraph.trim());
          }
          
          // Filter out very short paragraphs (likely headers, footers, etc.)
          const cleanParas = paragraphs
            .map(p => p.replace(/\s+/g, ' ').trim())
            .filter(p => p.length > 30);
          
          pageData.push({
            pageNum: i,
            paragraphs: cleanParas.length > 0 ? cleanParas : ['No paragraphs found']
          });
        }
        
        // Flatten for allParagraphs array
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        
        displayResults(file.name, pageData);
      } catch (error) {
        alert('Error processing PDF: ' + error.message);
        resetApp();
      }
    }
    
    async function displayResults(fileName, pageData) {
      loading.classList.remove('show');
      results.classList.add('show');
      copyAllBtn.style.display = 'block';
      
      // Store current file name
      currentFileName = fileName;
      
      // Save current file state for refresh persistence
      await saveCurrentFileState(currentFileId, fileName, 0);
      
      // Load last copied page for this file
      const savedLastCopied = await loadLastCopiedPage(fileName);
      if (savedLastCopied !== null) {
        lastCopiedPageNum = savedLastCopied;
        lastCopiedBtn.classList.add('show');
      }
      
      const totalParas = pageData.reduce((sum, p) => sum + p.paragraphs.length, 0);
      document.getElementById('fileName').textContent = fileName;
      document.getElementById('paraCount').textContent = totalParas;
      
      const container = document.getElementById('paragraphsContainer');
      let globalIndex = 0;
      
      container.innerHTML = pageData.map(page => {
        const pageStartIdx = globalIndex;
        const pageKey = `${fileName}_page_${page.pageNum}`;
        const savedNote = pageNotes[pageKey] || '';
        
        const pageHTML = `
          <div class="page-section" data-page="${page.pageNum}">
            <div class="page-header">Page ${page.pageNum}</div>
            <div class="paragraphs-grid">
              ${page.paragraphs.map((p, i) => {
                const idx = globalIndex++;
                return `
                  <div class="paragraph-item" id="para-btn-${idx}">
                    <input type="checkbox" class="para-checkbox" id="check-${idx}" data-index="${idx}" onclick="event.stopPropagation(); toggleParagraph(${idx})">
                    <label onclick="copyParagraph(${idx})">P${i + 1}</label>
                  </div>
                `;
              }).join('')}
            </div>
            <div class="page-actions">
              <button class="page-btn" onclick="selectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Select All</button>
              <button class="page-btn" onclick="deselectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Deselect All</button>
              <button class="page-btn" onclick="copySelectedInPage(${pageStartIdx}, ${globalIndex})">Copy Selected</button>
              <button class="page-btn" style="background: #4CAF50;" onclick="copyAllInPage(${pageStartIdx}, ${globalIndex}, event)">üìã Copy All Page</button>
            </div>
            <div class="page-notes">
              <div class="notes-header">
                <span class="notes-title">üìù Notes</span>
                <div class="notes-actions">
                  <button class="notes-btn" id="speak-btn-${page.pageNum}" onclick="toggleSpeech('${pageKey}', ${page.pageNum})" title="Play/Pause speech">
                    üîä Speak
                  </button>
                  <button class="notes-btn stop" id="stop-btn-${page.pageNum}" onclick="stopSpeech(${page.pageNum})" title="Stop speech" style="display: none;">
                    ‚èπÔ∏è Stop
                  </button>
                  <div class="font-size-controls">
                    <button class="notes-btn font-control" onclick="changeFontSize('${pageKey}', -1)" title="Decrease font size">
                      A-
                    </button>
                    <button class="notes-btn font-control" onclick="changeFontSize('${pageKey}', 1)" title="Increase font size">
                      A+
                    </button>
                  </div>
                  <span class="notes-saved" id="saved-${page.pageNum}">‚úì Saved</span>
                </div>
              </div>
              <div class="speed-control">
                <label class="speed-label">Speed: <span class="speed-value" id="speed-value-${page.pageNum}">1.0x</span></label>
                <input 
                  type="range" 
                  class="speed-slider" 
                  id="speed-${page.pageNum}"
                  min="0.5" 
                  max="2.0" 
                  step="0.1" 
                  value="1.0"
                  oninput="updateSpeedDisplay(${page.pageNum})"
                  title="Adjust speech speed"
                >
              </div>
              <div 
                class="notes-display editable" 
                contenteditable="true"
                data-placeholder="Add your notes for this page..."
                data-page-key="${pageKey}"
                data-page-num="${page.pageNum}"
                oninput="handleNoteChange('${pageKey}', ${page.pageNum})"
              >${savedNote}</div>
            </div>
          </div>
        `;
        return pageHTML;
      }).join('');
      
      // Restore scroll position after a short delay to ensure content is rendered
      if (scrollRestorePosition > 0) {
        setTimeout(() => {
          window.scrollTo({
            top: scrollRestorePosition,
            behavior: 'auto'
          });
          scrollRestorePosition = 0; // Reset after restoring
        }, 100);
      }
    }
    
    let noteTimeout;
    function handleNoteChange(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const savedIndicator = document.getElementById(`saved-${pageNum}`);
      
      clearTimeout(noteTimeout);
      savedIndicator.classList.remove('show');
      
      noteTimeout = setTimeout(async () => {
        const note = notesDiv.textContent;
        pageNotes[pageKey] = note;
        await savePageNote(pageKey, note);
        
        savedIndicator.classList.add('show');
        setTimeout(() => {
          savedIndicator.classList.remove('show');
        }, 2000);
      }, 500);
    }
    
    // Text-to-Speech functionality
    let currentSpeech = null;
    let currentSpeakingPage = null;
    let originalText = '';
    let highlightInterval = null;
    let isPaused = false;
    
    function updateSpeedDisplay(pageNum) {
      const slider = document.getElementById(`speed-${pageNum}`);
      const display = document.getElementById(`speed-value-${pageNum}`);
      display.textContent = slider.value + 'x';
    }
    
    // Font size control for notes
    function changeFontSize(pageKey, delta) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      if (!notesDiv) return;
      
      const currentSize = parseInt(window.getComputedStyle(notesDiv).fontSize);
      const newSize = Math.max(10, Math.min(24, currentSize + delta));
      notesDiv.style.fontSize = newSize + 'px';
    }
    
    // Stop speech completely
    function stopSpeech(pageNum) {
      if (currentSpeech && currentSpeakingPage === pageNum) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        
        const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
        const stopBtn = document.getElementById(`stop-btn-${pageNum}`);
        const notesDiv = document.querySelector(`[data-page-num="${pageNum}"]`);
        
        if (speakBtn) {
          speakBtn.classList.remove('speaking', 'paused');
          speakBtn.innerHTML = 'üîä Speak';
        }
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        if (notesDiv) {
          clearHighlights(notesDiv);
        }
        
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
      }
    }
    
    function clearHighlights(notesDiv) {
      if (originalText) {
        notesDiv.textContent = originalText;
        originalText = '';
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function scrollToHighlight(notesDiv) {
      const highlightedWord = notesDiv.querySelector('.highlight-word');
      if (highlightedWord) {
        // Get the position of the highlighted word relative to the container
        const containerRect = notesDiv.getBoundingClientRect();
        const wordRect = highlightedWord.getBoundingClientRect();
        
        // Calculate if the word is outside the visible area
        const isAbove = wordRect.top < containerRect.top;
        const isBelow = wordRect.bottom > containerRect.bottom;
        
        if (isAbove || isBelow) {
          // Scroll to center the highlighted word
          const wordTop = highlightedWord.offsetTop;
          const containerHeight = notesDiv.clientHeight;
          const wordHeight = highlightedWord.offsetHeight;
          
          notesDiv.scrollTop = wordTop - (containerHeight / 2) + (wordHeight / 2);
        }
      }
    }
    
    function highlightTextAtPosition(notesDiv, charIndex, text) {
      // Find word boundaries around the character position
      let wordStart = charIndex;
      let wordEnd = charIndex;
      
      // Find start of word
      while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) {
        wordStart--;
      }
      
      // Find end of word
      while (wordEnd < text.length && !/\s/.test(text[wordEnd])) {
        wordEnd++;
      }
      
      // Build HTML with highlighted word
      const before = escapeHtml(text.substring(0, wordStart));
      const word = escapeHtml(text.substring(wordStart, wordEnd));
      const after = escapeHtml(text.substring(wordEnd));
      
      notesDiv.innerHTML = before + '<span class="highlight-word">' + word + '</span>' + after;
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(notesDiv);
    }
    
    function highlightWordByIndex(notesDiv, wordIndex, words) {
      const htmlParts = words.map((word, idx) => {
        if (idx === wordIndex) {
          return '<span class="highlight-word">' + escapeHtml(word) + '</span>';
        }
        return escapeHtml(word);
      });
      notesDiv.innerHTML = htmlParts.join(' ');
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(notesDiv);
    }
    
    function toggleSpeech(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
      const stopBtn = document.getElementById(`stop-btn-${pageNum}`);
      const speedSlider = document.getElementById(`speed-${pageNum}`);
      
      if (!notesDiv || !speakBtn || !speedSlider) {
        console.error('Required elements not found');
        return;
      }
      
      const noteText = notesDiv.textContent.trim();
      
      // If currently speaking this page, toggle pause/resume
      if (currentSpeakingPage === pageNum && currentSpeech) {
        if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
          // Pause
          window.speechSynthesis.pause();
          isPaused = true;
          speakBtn.classList.remove('speaking');
          speakBtn.classList.add('paused');
          speakBtn.innerHTML = '‚ñ∂Ô∏è Resume';
          clearInterval(highlightInterval);
          console.log('Speech paused');
        } else if (window.speechSynthesis.paused) {
          // Resume
          window.speechSynthesis.resume();
          isPaused = false;
          speakBtn.classList.remove('paused');
          speakBtn.classList.add('speaking');
          speakBtn.innerHTML = '‚è∏Ô∏è Pause';
          console.log('Speech resumed');
        }
        return;
      }
      
      // Stop any other speech
      if (currentSpeech) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        if (currentSpeakingPage !== null) {
          const prevBtn = document.getElementById(`speak-btn-${currentSpeakingPage}`);
          const prevNotesDiv = document.querySelector(`[data-page-num="${currentSpeakingPage}"]`);
          if (prevBtn) {
            prevBtn.classList.remove('speaking');
            prevBtn.innerHTML = 'üîä Speak';
          }
          if (prevNotesDiv) {
            clearHighlights(prevNotesDiv);
          }
        }
      }
      
      if (!noteText) {
        alert('No notes to read. Please add some notes first.');
        return;
      }
      
      // Check if speech synthesis is supported
      if (!('speechSynthesis' in window)) {
        alert('Text-to-speech is not supported in your browser.');
        return;
      }
      
      // Cancel any pending speech
      window.speechSynthesis.cancel();
      
      // Store original text
      originalText = noteText;
      
      // Split text into words for fallback highlighting
      const words = noteText.split(/\s+/);
      let currentWordIndex = 0;
      let boundarySupported = false;
      
      // Check text length - mobile browsers have limits
      const maxLength = 4000; // Safe limit for mobile
      let textToSpeak = noteText;
      if (noteText.length > maxLength) {
        textToSpeak = noteText.substring(0, maxLength);
        console.warn('Text truncated for mobile compatibility');
      }
      
      // Create and configure speech
      currentSpeech = new SpeechSynthesisUtterance(textToSpeak);
      currentSpeakingPage = pageNum;
      
      // Configure speech properties with user-selected speed
      const speed = parseFloat(speedSlider.value);
      currentSpeech.rate = speed;
      currentSpeech.pitch = 1.0;
      currentSpeech.volume = 1.0;
      
      // Try to get a voice (helps with mobile)
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
        // Prefer English voices
        const englishVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
        currentSpeech.voice = englishVoice;
        currentSpeech.lang = englishVoice.lang;
      } else {
        currentSpeech.lang = 'en-US';
      }
      
      console.log('Starting speech with text:', textToSpeak.substring(0, 50) + '...');
      console.log('Speech rate:', speed);
      console.log('Available voices:', voices.length);
      
      // Update button state
      speakBtn.classList.add('speaking');
      speakBtn.innerHTML = '‚è∏Ô∏è Pause';
      if (stopBtn) {
        stopBtn.style.display = 'flex';
      }
      
      // Try to use boundary events (more accurate)
      currentSpeech.onboundary = (event) => {
        if (event.name === 'word' && event.charIndex !== undefined) {
          boundarySupported = true;
          // Clear the fallback interval once we know boundary events work
          if (highlightInterval) {
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
          highlightTextAtPosition(notesDiv, event.charIndex, noteText);
        }
      };
      
      // Handle speech start - begin highlighting when speech actually starts
      currentSpeech.onstart = () => {
        console.log('Speech started');
        // Fallback: timer-based highlighting (faster timing for better sync)
        const avgWordDuration = (60000 / (180 * speed)); // 180 WPM for faster highlighting
        
        // Start highlighting with first word
        if (words.length > 0) {
          highlightWordByIndex(notesDiv, 0, words);
          currentWordIndex = 1;
        }
        
        highlightInterval = setInterval(() => {
          if (!boundarySupported && currentWordIndex < words.length) {
            highlightWordByIndex(notesDiv, currentWordIndex, words);
            currentWordIndex++;
          }
        }, avgWordDuration);
      };
      
      // Handle speech end
      currentSpeech.onend = () => {
        speakBtn.classList.remove('speaking', 'paused');
        speakBtn.innerHTML = 'üîä Speak';
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
      };
      
      // Handle speech error
      currentSpeech.onerror = (event) => {
        console.error('Speech error:', event);
        let errorMsg = 'Speech error: ' + event.error;
        
        // Provide helpful messages for common mobile errors
        if (event.error === 'synthesis-failed') {
          errorMsg = 'Speech failed. Try:\n1. Reduce note length\n2. Check device volume\n3. Restart browser\n4. Enable speech in device settings';
        } else if (event.error === 'not-allowed') {
          errorMsg = 'Speech not allowed. Please interact with the page first (tap anywhere).';
        } else if (event.error === 'network') {
          errorMsg = 'Network error. Check your internet connection.';
        }
        
        alert(errorMsg);
        speakBtn.classList.remove('speaking', 'paused');
        speakBtn.innerHTML = 'üîä Speak';
        if (stopBtn) {
          stopBtn.style.display = 'none';
        }
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        isPaused = false;
      };
      
      // Mobile-specific: Load voices first if not loaded
      if (window.speechSynthesis.getVoices().length === 0) {
        window.speechSynthesis.addEventListener('voiceschanged', function loadVoices() {
          const voices = window.speechSynthesis.getVoices();
          if (voices.length > 0 && currentSpeech) {
            const englishVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
            currentSpeech.voice = englishVoice;
            currentSpeech.lang = englishVoice.lang;
          }
          window.speechSynthesis.removeEventListener('voiceschanged', loadVoices);
        });
      }
      
      // Start speaking - with a small delay to ensure everything is ready
      setTimeout(() => {
        try {
          // Mobile fix: Cancel any pending speech first
          window.speechSynthesis.cancel();
          
          // Small delay before speaking (helps on mobile)
          setTimeout(() => {
            window.speechSynthesis.speak(currentSpeech);
            console.log('Speech queued successfully');
          }, 50);
        } catch (error) {
          console.error('Failed to start speech:', error);
          alert('Failed to start speech: ' + error.message);
          speakBtn.classList.remove('speaking');
          speakBtn.innerHTML = 'üîä Speak';
          if (stopBtn) {
            stopBtn.style.display = 'none';
          }
        }
      }, 100);
    }
    
    function toggleParagraph(index) {
      const checkbox = document.getElementById('check-' + index);
      updateParagraphStyle(index);
    }
    
    function updateParagraphStyle(index) {
      const checkbox = document.getElementById('check-' + index);
      const btn = document.getElementById('para-btn-' + index);
      
      if (checkbox.checked) {
        btn.classList.add('selected');
      } else {
        btn.classList.remove('selected');
      }
    }
    
    function selectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = true;
          updateParagraphStyle(i);
        }
      }
    }
    
    function deselectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = false;
          updateParagraphStyle(i);
        }
      }
    }
    
    async function copySelectedInPage(startIdx, endIdx) {
      const selectedTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox && checkbox.checked) {
          selectedTexts.push(allParagraphs[i]);
        }
      }
      
      if (selectedTexts.length === 0) {
        return;
      }
      
      const combinedText = selectedTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(async () => {
        // Store the page number for last copied button
        const pageSection = event.target.closest('.page-section');
        if (pageSection) {
          lastCopiedPageNum = parseInt(pageSection.dataset.page);
          await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
          lastCopiedBtn.classList.add('show');
        }
        showCopyFeedback(event.target);
      });
    }
    
    async function copyAllInPage(startIdx, endIdx, event) {
      const pageTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        pageTexts.push(allParagraphs[i]);
      }
      
      const combinedText = pageTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(async () => {
        // Store the page number for last copied button
        const pageSection = event.target.closest('.page-section');
        if (pageSection) {
          lastCopiedPageNum = parseInt(pageSection.dataset.page);
          await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
          lastCopiedBtn.classList.add('show');
        }
        showCopyFeedback(event.target);
      });
    }
    
    function showCopyFeedback(button) {
      const originalText = button.textContent;
      const originalBg = button.style.background;
      button.textContent = '‚úì Copied!';
      button.style.background = '#4CAF50';
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = originalBg;
      }, 2000);
    }
    
    async function copyParagraph(index) {
      const text = allParagraphs[index];
      navigator.clipboard.writeText(text).then(async () => {
        // Store the page number for last copied button
        const paraBtn = document.getElementById(`para-btn-${index}`);
        if (paraBtn) {
          const pageSection = paraBtn.closest('.page-section');
          if (pageSection) {
            lastCopiedPageNum = parseInt(pageSection.dataset.page);
            await saveLastCopiedPage(currentFileName, lastCopiedPageNum);
            lastCopiedBtn.classList.add('show');
          }
        }
        
        const label = document.querySelector(`#para-btn-${index} label`);
        const originalText = label.textContent;
        label.textContent = '‚úì';
        setTimeout(() => {
          label.textContent = originalText;
        }, 1500);
      });
    }
    
    function copyAll() {
      const selectedTexts = [];
      
      // Check if any checkboxes are selected
      document.querySelectorAll('.para-checkbox:checked').forEach(checkbox => {
        const index = parseInt(checkbox.dataset.index);
        selectedTexts.push(allParagraphs[index]);
      });
      
      // If nothing selected, copy all
      const textToCopy = selectedTexts.length > 0 ? selectedTexts.join('\n\n') : allParagraphs.join('\n\n');
      const count = selectedTexts.length > 0 ? selectedTexts.length : allParagraphs.length;
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        const btn = copyAllBtn;
        const originalText = btn.textContent;
        btn.textContent = `‚úì Copied ${count}!`;
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      });
    }
    
    async function resetApp() {
      // Clear current file state
      if (db) {
        try {
          const transaction = db.transaction([notesStoreName], 'readwrite');
          const objectStore = transaction.objectStore(notesStoreName);
          objectStore.delete('_currentFileState');
        } catch (e) {
          console.error('Error clearing file state:', e);
        }
      }
      
      uploadSection.style.display = 'block';
      results.classList.remove('show');
      copyAllBtn.style.display = 'none';
      scrollTopBtn.classList.remove('show');
      lastCopiedBtn.classList.remove('show');
      fileInput.value = '';
      allParagraphs = [];
      lastCopiedPageNum = null;
      currentFileId = null;
      currentFileName = '';
      
      // Redirect to file manager
      window.location.href = 'upload.html';
    }
    
    // Scroll to top functionality
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // Scroll to last copied page
    function scrollToLastCopied() {
      if (lastCopiedPageNum !== null) {
        const pageSection = document.querySelector(`[data-page="${lastCopiedPageNum}"]`);
        if (pageSection) {
          pageSection.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
          // Highlight the page briefly
          pageSection.style.transition = 'background 0.5s';
          pageSection.style.background = '#fff3cd';
          setTimeout(() => {
            pageSection.style.background = '#f8f9ff';
          }, 1500);
        }
      }
    }
    
    // Show/hide scroll to top button based on scroll position
    // Also save scroll position for refresh persistence
    let scrollSaveTimeout;
    window.addEventListener('scroll', () => {
      if (window.pageYOffset > 300) {
        scrollTopBtn.classList.add('show');
      } else {
        scrollTopBtn.classList.remove('show');
      }
      
      // Debounce scroll position saving
      clearTimeout(scrollSaveTimeout);
      scrollSaveTimeout = setTimeout(async () => {
        if (currentFileId && currentFileName) {
          await saveCurrentFileState(currentFileId, currentFileName, window.pageYOffset);
        }
      }, 500);
    });
    
    // Go back to file manager
    function goBackToManager() {
      window.location.href = 'upload.html';
    }
  </script>
</body>
</html>
