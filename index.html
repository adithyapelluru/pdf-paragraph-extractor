<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="refresh" content="0; url=upload.html">
  <title>PDF Paragraph Extractor - Redirecting...</title> 
  <style>
    :root {
      --bg-gradient-start: #667eea;
      --bg-gradient-end: #764ba2;
      --container-bg: white;
      --text-color: #333;
      --text-secondary: #666;
      --border-color: #ddd;
      --section-bg: #f8f9ff;
      --section-hover: #f0f2ff;
      --section-active: #e8ebff;
      --shadow-color: rgba(0,0,0,0.3);
    }
    
    [data-theme="dark"] {
      --bg-gradient-start: #000000;
      --bg-gradient-end: #000000;
      --container-bg: #000000;
      --text-color: #e0e0e0;
      --text-secondary: #b0b0b0;
      --border-color: #1a1a1a;
      --section-bg: #000000;
      --section-hover: #0a0a0a;
      --section-active: #151515;
      --shadow-color: rgba(0,0,0,0.9);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      transition: background 0.3s ease;
    }
    
    .container {
      background: var(--container-bg);
      border-radius: 20px;
      box-shadow: 0 20px 60px var(--shadow-color);
      max-width: 1200px;
      width: 100%;
      overflow: hidden;
      transition: background 0.3s ease;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
      transition: background 0.3s ease;
    }
    
    [data-theme="dark"] .header {
      background: #000000;
      border-bottom: 2px solid #1a1a1a;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    .header p {
      opacity: 0.9;
      font-size: 16px;
    }
    
    .upload-section {
      padding: 40px;
      text-align: center;
    }
    
    .upload-box {
      border: 3px dashed #667eea;
      border-radius: 15px;
      padding: 60px 40px;
      background: var(--section-bg);
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-box:hover {
      background: var(--section-hover);
      border-color: #764ba2;
    }
    
    .upload-box.dragover {
      background: var(--section-active);
      border-color: #764ba2;
      transform: scale(1.02);
    }
    
    .upload-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    
    .upload-text {
      font-size: 20px;
      color: var(--text-color);
      margin-bottom: 10px;
      transition: color 0.3s ease;
    }
    
    .upload-hint {
      color: var(--text-secondary);
      font-size: 14px;
      transition: color 0.3s ease;
    }
    
    .file-input {
      display: none;
    }
    
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    [data-theme="dark"] .btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    [data-theme="dark"] .btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .results {
      padding: 40px;
      display: none;
    }
    
    .results.show {
      display: block;
    }
    
    .file-info {
      background: var(--section-bg);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text-color);
      transition: background 0.3s ease, color 0.3s ease;
    }
    
    .page-section {
      margin-bottom: 30px;
      background: var(--section-bg);
      padding: 20px;
      border-radius: 15px;
      transition: background 0.3s ease;
    }
    
    .page-header {
      font-size: 20px;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #667eea;
    }
    
    .paragraphs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }
    
    .paragraph-item {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    [data-theme="dark"] .paragraph-item {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .paragraph-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }
    
    .paragraph-item.selected {
      background: #FF9800;
    }
    
    [data-theme="dark"] .paragraph-item.selected {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .paragraph-item.copied {
      background: #4CAF50;
    }
    
    [data-theme="dark"] .paragraph-item.copied {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    .para-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    
    .paragraph-item label {
      cursor: pointer;
      user-select: none;
    }
    
    .page-actions {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: flex-start;
    }
    
    .page-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    [data-theme="dark"] .page-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .page-btn:hover {
      background: #764ba2;
    }
    
    [data-theme="dark"] .page-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .page-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    [data-theme="dark"] .page-btn:disabled {
      background: #000000;
      border-color: #1a1a1a;
      color: #666;
    }
    
    .page-notes {
      margin-top: 15px;
      padding: 15px;
      background: var(--container-bg);
      border-radius: 10px;
      border: 2px solid #667eea;
      transition: background 0.3s ease;
    }
    
    .notes-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .notes-title {
      font-weight: bold;
      color: #667eea;
      font-size: 16px;
    }
    
    .notes-textarea {
      width: 100%;
      min-height: 80px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
      transition: border-color 0.3s;
      display: none;
    }
    
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .notes-display {
      width: 100%;
      height: 120px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: var(--section-bg);
      overflow-y: auto;
      scroll-behavior: smooth;
      color: var(--text-color);
      transition: background 0.3s ease, color 0.3s ease;
    }
    
    .notes-display.editable {
      cursor: text;
    }
    
    .notes-display:empty:before {
      content: attr(data-placeholder);
      color: #999;
    }
    
    .highlight-word {
      background: #FFD700;
      color: #000;
      padding: 2px 0;
      border-radius: 3px;
      animation: highlight-pulse 0.3s ease;
    }
    
    @keyframes highlight-pulse {
      0% { background: #FFD700; }
      50% { background: #FFA500; }
      100% { background: #FFD700; }
    }
    
    .notes-saved {
      color: #4CAF50;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .notes-saved.show {
      opacity: 1;
    }
    
    .notes-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .notes-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    [data-theme="dark"] .notes-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .notes-btn:hover {
      background: #764ba2;
      transform: translateY(-1px);
    }
    
    [data-theme="dark"] .notes-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .notes-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    [data-theme="dark"] .notes-btn:disabled {
      background: #000000;
      border-color: #1a1a1a;
      color: #666;
    }
    
    .notes-btn.speaking {
      background: #FF9800;
      animation: pulse 1.5s infinite;
    }
    
    [data-theme="dark"] .notes-btn.speaking {
      background: #000000;
      border-color: #1a1a1a;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: var(--section-hover);
      border-radius: 8px;
      transition: background 0.3s ease;
    }
    
    .speed-label {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 80px;
    }
    
    .speed-slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }
    
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .speed-slider::-webkit-slider-thumb:hover {
      background: #764ba2;
    }
    
    .speed-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      border: none;
      transition: background 0.3s;
    }
    
    .speed-slider::-moz-range-thumb:hover {
      background: #764ba2;
    }
    
    .speed-value {
      font-size: 12px;
      color: #667eea;
      font-weight: bold;
      min-width: 35px;
      text-align: right;
    }
    
    .floating-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: #4CAF50;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
      transition: all 0.3s;
      z-index: 1000;
    }
    
    [data-theme="dark"] .floating-btn {
      background: #000000;
      border: 2px solid #1a1a1a;
    }
    
    .floating-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.5);
    }
    
    [data-theme="dark"] .floating-btn:hover {
      background: #0a0a0a;
      border-color: #1a1a1a;
    }
    
    .back-btn {
      background: #666;
      margin-right: 10px;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      display: none;
    }
    
    .loading.show {
      display: block;
    }
    
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .header h1 {
        font-size: 24px;
      }
      
      .header p {
        font-size: 14px;
      }
      
      .upload-section, .results {
        padding: 20px;
      }
      
      .upload-box {
        padding: 30px 20px;
      }
      
      .upload-icon {
        font-size: 48px;
      }
      
      .upload-text {
        font-size: 18px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
      
      .file-info {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      .page-section {
        padding: 15px;
      }
      
      .page-header {
        font-size: 18px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        gap: 8px;
      }
      
      .paragraph-item {
        padding: 10px;
        font-size: 14px;
      }
      
      .para-checkbox {
        width: 16px;
        height: 16px;
      }
      
      .page-actions {
        flex-wrap: wrap;
      }
      
      .page-btn {
        font-size: 12px;
        padding: 6px 12px;
      }
      
      .notes-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .notes-display {
        height: 100px;
        font-size: 13px;
      }
      
      .speed-control {
        flex-direction: column;
        align-items: stretch;
      }
      
      .speed-label {
        min-width: auto;
      }
      
      .floating-btn {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 14px;
      }
    }
    
    @media (max-width: 480px) {
      .header h1 {
        font-size: 20px;
      }
      
      .paragraphs-grid {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }
      
      .paragraph-item {
        padding: 8px;
        font-size: 12px;
      }
      
      .page-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .notes-title {
        font-size: 14px;
      }
      
      .notes-btn {
        font-size: 11px;
        padding: 5px 10px;
      }
      
      .floating-btn {
        padding: 10px 15px;
        font-size: 12px;
      }
    }
    
    .theme-toggle-btn {
      position: fixed;
      top: 30px;
      right: 30px;
      background: #667eea;
      color: white;
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .theme-toggle-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      background: #764ba2;
    }
    
    @media (max-width: 768px) {
      .theme-toggle-btn {
        top: 15px;
        right: 15px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
    }
    
    @media (max-width: 480px) {
      .theme-toggle-btn {
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìÑ PDF & EPUB Paragraph Extractor</h1>
      <p>Upload a PDF or EPUB and copy paragraphs with ease</p>
      <p style="margin-top: 10px;"><a href="upload.html" style="color: white; text-decoration: underline;">Go to File Manager</a></p>
    </div>
    
    <div class="upload-section" id="uploadSection">
      <div class="upload-box" id="uploadBox">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Drop your PDF or EPUB here</div>
        <div class="upload-hint">or click to browse</div>
        <input type="file" id="fileInput" class="file-input" accept=".pdf,.epub">
        <button class="btn" onclick="document.getElementById('fileInput').click()">Choose PDF/EPUB File</button>
      </div>
    </div>
    
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <p>Extracting paragraphs...</p>
    </div>
    
    <div class="results" id="results">
      <div class="file-info">
        <div>
          <strong>File:</strong> <span id="fileName"></span><br>
          <strong>Paragraphs:</strong> <span id="paraCount"></span>
        </div>
        <button class="btn back-btn" onclick="resetApp()">Upload Another</button>
      </div>
      <div id="paragraphsContainer"></div>
    </div>
  </div>
  
  <button class="floating-btn" id="copyAllBtn" style="display: none;" onclick="copyAll()">
    üìã Copy All
  </button>
  
  <button class="theme-toggle-btn" onclick="toggleTheme()" title="Toggle dark mode" id="themeToggle">
    üåô
  </button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allParagraphs = [];
    let db;
    
    const uploadBox = document.getElementById('uploadBox');
    const fileInput = document.getElementById('fileInput');
    const uploadSection = document.getElementById('uploadSection');
    const loading = document.getElementById('loading');
    const results = document.getElementById('results');
    const copyAllBtn = document.getElementById('copyAllBtn');
    
    // IndexedDB setup
    const dbName = 'FileExtractorDB';
    const storeName = 'files';
    const notesStoreName = 'pageNotes';
    let pageNotes = {};
    
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 4);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains(notesStoreName)) {
            db.createObjectStore(notesStoreName, { keyPath: 'pageKey' });
          }
          if (!db.objectStoreNames.contains('savedQuotes')) {
            db.createObjectStore('savedQuotes', { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains('savedMeanings')) {
            db.createObjectStore('savedMeanings', { keyPath: 'id', autoIncrement: true });
          }
        };
      });
    }
    
    async function savePageNote(pageKey, note) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readwrite');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.put({ pageKey, note });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
    
    async function loadPageNotes() {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([notesStoreName], 'readonly');
        const objectStore = transaction.objectStore(notesStoreName);
        const request = objectStore.getAll();
        
        request.onsuccess = () => {
          const notes = {};
          request.result.forEach(item => {
            notes[item.pageKey] = item.note;
          });
          resolve(notes);
        };
        request.onerror = () => reject(request.error);
      });
    }
    
    async function getFileById(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([storeName], 'readonly');
        const objectStore = transaction.objectStore(storeName);
        const request = objectStore.get(id);
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    // Check if file was selected from upload page
    window.addEventListener('load', async () => {
      await initDB();
      pageNotes = await loadPageNotes();
      
      const currentFileId = localStorage.getItem('currentFileId');
      if (currentFileId) {
        const fileData = await getFileById(parseInt(currentFileId));
        localStorage.removeItem('currentFileId');
        
        if (fileData) {
          // Convert data URL back to file
          fetch(fileData.data)
            .then(res => res.blob())
            .then(blob => {
              const newFile = new File([blob], fileData.name, { type: blob.type });
              processFile(newFile);
            });
        }
      }
    });
    
    // Drag and drop
    uploadBox.addEventListener('click', () => fileInput.click());
    
    uploadBox.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadBox.classList.add('dragover');
    });
    
    uploadBox.addEventListener('dragleave', () => {
      uploadBox.classList.remove('dragover');
    });
    
    uploadBox.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadBox.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && (file.type === 'application/pdf' || file.name.endsWith('.epub'))) {
        processFile(file);
      }
    });
    
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        processFile(file);
      }
      // Reset input so same file can be selected again
      e.target.value = '';
    });
    
    async function processFile(file) {
      if (file.name.endsWith('.epub')) {
        await processEPUB(file);
      } else {
        await processPDF(file);
      }
    }
    
    async function processEPUB(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const JSZip = window.JSZip || await loadJSZip();
        const zip = await JSZip.loadAsync(file);
        
        // Find all HTML/XHTML files in the EPUB
        const htmlFiles = Object.keys(zip.files).filter(name => 
          name.match(/\.(html|xhtml|htm)$/i) && !name.startsWith('__MACOSX')
        );
        
        const pageData = [];
        let pageNum = 1;
        
        for (const fileName of htmlFiles) {
          const content = await zip.files[fileName].async('text');
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          
          // Remove script and style tags
          doc.querySelectorAll('script, style').forEach(el => el.remove());
          
          // Extract paragraphs from the HTML
          const paragraphs = [];
          const textElements = doc.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
          
          textElements.forEach(el => {
            const text = el.textContent.trim();
            if (text.length > 30) {
              paragraphs.push(text);
            }
          });
          
          if (paragraphs.length > 0) {
            pageData.push({
              pageNum: pageNum++,
              paragraphs: paragraphs
            });
          }
        }
        
        if (pageData.length === 0) {
          throw new Error('No readable content found in EPUB');
        }
        
        // Flatten for allParagraphs array
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        
        displayResults(file.name, pageData);
      } catch (error) {
        alert('Error processing EPUB: ' + error.message);
        resetApp();
      }
    }
    
    async function loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    async function processPDF(file) {
      uploadSection.style.display = 'none';
      loading.classList.add('show');
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        const pageData = [];
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          
          // Group text items by line
          const lines = [];
          let currentLine = { items: [], y: null };
          
          textContent.items.forEach(item => {
            const y = Math.round(item.transform[5]);
            
            // If this is a new line
            if (currentLine.y === null || Math.abs(currentLine.y - y) > 5) {
              if (currentLine.items.length > 0) {
                lines.push(currentLine);
              }
              currentLine = { items: [item], y: y };
            } else {
              // Same line, add to current line
              currentLine.items.push(item);
            }
          });
          
          // Add the last line
          if (currentLine.items.length > 0) {
            lines.push(currentLine);
          }
          
          // Sort lines by Y position (top to bottom)
          lines.sort((a, b) => b.y - a.y);
          
          // Build paragraphs from lines
          const paragraphs = [];
          let currentParagraph = '';
          let lastLineY = null;
          
          lines.forEach(line => {
            // Sort items in line by X position (left to right)
            line.items.sort((a, b) => a.transform[4] - b.transform[4]);
            
            // Combine items in line to form text
            const lineText = line.items.map(item => item.str).join(' ');
            
            // Check if this is a new paragraph
            // Paragraph break if:
            // 1. Large vertical gap (more than 1.5x typical line height)
            // 2. The line is indented (first line of paragraph)
            // 3. The previous line ended with a sentence terminator
            
            const isLargeGap = lastLineY !== null && (lastLineY - line.y) > 20;
            const isIndented = line.items[0]?.transform[4] > 50;
            const prevEndsWithTerminator = /[.!?]\s*$/.test(currentParagraph);
            
            if (currentParagraph && (isLargeGap || (isIndented && prevEndsWithTerminator))) {
              paragraphs.push(currentParagraph.trim());
              currentParagraph = lineText;
            } else {
              // Continue current paragraph
              currentParagraph += (currentParagraph ? ' ' : '') + lineText;
            }
            
            lastLineY = line.y;
          });
          
          // Add the last paragraph
          if (currentParagraph.trim()) {
            paragraphs.push(currentParagraph.trim());
          }
          
          // Filter out very short paragraphs (likely headers, footers, etc.)
          const cleanParas = paragraphs
            .map(p => p.replace(/\s+/g, ' ').trim())
            .filter(p => p.length > 30);
          
          pageData.push({
            pageNum: i,
            paragraphs: cleanParas.length > 0 ? cleanParas : ['No paragraphs found']
          });
        }
        
        // Flatten for allParagraphs array
        allParagraphs = pageData.flatMap(p => p.paragraphs);
        
        displayResults(file.name, pageData);
      } catch (error) {
        alert('Error processing PDF: ' + error.message);
        resetApp();
      }
    }
    
    function displayResults(fileName, pageData) {
      loading.classList.remove('show');
      results.classList.add('show');
      copyAllBtn.style.display = 'block';
      
      const totalParas = pageData.reduce((sum, p) => sum + p.paragraphs.length, 0);
      document.getElementById('fileName').textContent = fileName;
      document.getElementById('paraCount').textContent = totalParas;
      
      const container = document.getElementById('paragraphsContainer');
      let globalIndex = 0;
      
      container.innerHTML = pageData.map(page => {
        const pageStartIdx = globalIndex;
        const pageKey = `${fileName}_page_${page.pageNum}`;
        const savedNote = pageNotes[pageKey] || '';
        
        const pageHTML = `
          <div class="page-section" data-page="${page.pageNum}">
            <div class="page-header">Page ${page.pageNum}</div>
            <div class="paragraphs-grid">
              ${page.paragraphs.map((p, i) => {
                const idx = globalIndex++;
                return `
                  <div class="paragraph-item" id="para-btn-${idx}">
                    <input type="checkbox" class="para-checkbox" id="check-${idx}" data-index="${idx}" onclick="event.stopPropagation(); toggleParagraph(${idx})">
                    <label onclick="copyParagraph(${idx})">P${i + 1}</label>
                  </div>
                `;
              }).join('')}
            </div>
            <div class="page-actions">
              <button class="page-btn" onclick="selectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Select All</button>
              <button class="page-btn" onclick="deselectAllInPage(${page.pageNum}, ${pageStartIdx}, ${globalIndex})">Deselect All</button>
              <button class="page-btn" onclick="copySelectedInPage(${pageStartIdx}, ${globalIndex})">Copy Selected</button>
              <button class="page-btn" style="background: #4CAF50;" onclick="copyAllInPage(${pageStartIdx}, ${globalIndex}, event)">üìã Copy All Page</button>
            </div>
            <div class="page-notes">
              <div class="notes-header">
                <span class="notes-title">üìù Notes</span>
                <div class="notes-actions">
                  <button class="notes-btn" id="speak-btn-${page.pageNum}" onclick="toggleSpeech('${pageKey}', ${page.pageNum})" title="Read notes aloud">
                    üîä Speak
                  </button>
                  <span class="notes-saved" id="saved-${page.pageNum}">‚úì Saved</span>
                </div>
              </div>
              <div class="speed-control">
                <label class="speed-label">Speed: <span class="speed-value" id="speed-value-${page.pageNum}">1.0x</span></label>
                <input 
                  type="range" 
                  class="speed-slider" 
                  id="speed-${page.pageNum}"
                  min="0.5" 
                  max="2.0" 
                  step="0.1" 
                  value="1.0"
                  oninput="updateSpeedDisplay(${page.pageNum})"
                  title="Adjust speech speed"
                >
              </div>
              <div 
                class="notes-display editable" 
                contenteditable="true"
                data-placeholder="Add your notes for this page..."
                data-page-key="${pageKey}"
                data-page-num="${page.pageNum}"
                oninput="handleNoteChange('${pageKey}', ${page.pageNum})"
              >${savedNote}</div>
            </div>
          </div>
        `;
        return pageHTML;
      }).join('');
    }
    
    let noteTimeout;
    function handleNoteChange(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const savedIndicator = document.getElementById(`saved-${pageNum}`);
      
      clearTimeout(noteTimeout);
      savedIndicator.classList.remove('show');
      
      noteTimeout = setTimeout(async () => {
        const note = notesDiv.textContent;
        pageNotes[pageKey] = note;
        await savePageNote(pageKey, note);
        
        savedIndicator.classList.add('show');
        setTimeout(() => {
          savedIndicator.classList.remove('show');
        }, 2000);
      }, 500);
    }
    
    // Text-to-Speech functionality
    let currentSpeech = null;
    let currentSpeakingPage = null;
    let originalText = '';
    let highlightInterval = null;
    
    function updateSpeedDisplay(pageNum) {
      const slider = document.getElementById(`speed-${pageNum}`);
      const display = document.getElementById(`speed-value-${pageNum}`);
      display.textContent = slider.value + 'x';
    }
    
    function clearHighlights(notesDiv) {
      if (originalText) {
        notesDiv.textContent = originalText;
        originalText = '';
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function scrollToHighlight(notesDiv) {
      const highlightedWord = notesDiv.querySelector('.highlight-word');
      if (highlightedWord) {
        // Get the position of the highlighted word relative to the container
        const containerRect = notesDiv.getBoundingClientRect();
        const wordRect = highlightedWord.getBoundingClientRect();
        
        // Calculate if the word is outside the visible area
        const isAbove = wordRect.top < containerRect.top;
        const isBelow = wordRect.bottom > containerRect.bottom;
        
        if (isAbove || isBelow) {
          // Scroll to center the highlighted word
          const wordTop = highlightedWord.offsetTop;
          const containerHeight = notesDiv.clientHeight;
          const wordHeight = highlightedWord.offsetHeight;
          
          notesDiv.scrollTop = wordTop - (containerHeight / 2) + (wordHeight / 2);
        }
      }
    }
    
    function highlightTextAtPosition(notesDiv, charIndex, text) {
      // Find word boundaries around the character position
      let wordStart = charIndex;
      let wordEnd = charIndex;
      
      // Find start of word
      while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) {
        wordStart--;
      }
      
      // Find end of word
      while (wordEnd < text.length && !/\s/.test(text[wordEnd])) {
        wordEnd++;
      }
      
      // Build HTML with highlighted word
      const before = escapeHtml(text.substring(0, wordStart));
      const word = escapeHtml(text.substring(wordStart, wordEnd));
      const after = escapeHtml(text.substring(wordEnd));
      
      notesDiv.innerHTML = before + '<span class="highlight-word">' + word + '</span>' + after;
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(notesDiv);
    }
    
    function highlightWordByIndex(notesDiv, wordIndex, words) {
      const htmlParts = words.map((word, idx) => {
        if (idx === wordIndex) {
          return '<span class="highlight-word">' + escapeHtml(word) + '</span>';
        }
        return escapeHtml(word);
      });
      notesDiv.innerHTML = htmlParts.join(' ');
      
      // Auto-scroll to keep highlighted word visible
      scrollToHighlight(notesDiv);
    }
    
    function toggleSpeech(pageKey, pageNum) {
      const notesDiv = document.querySelector(`[data-page-key="${pageKey}"]`);
      const speakBtn = document.getElementById(`speak-btn-${pageNum}`);
      const speedSlider = document.getElementById(`speed-${pageNum}`);
      const noteText = notesDiv.textContent.trim();
      
      // If currently speaking this page, stop it
      if (currentSpeakingPage === pageNum && currentSpeech) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        speakBtn.classList.remove('speaking');
        speakBtn.innerHTML = 'üîä Speak';
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
        return;
      }
      
      // Stop any other speech
      if (currentSpeech) {
        window.speechSynthesis.cancel();
        clearInterval(highlightInterval);
        if (currentSpeakingPage !== null) {
          const prevBtn = document.getElementById(`speak-btn-${currentSpeakingPage}`);
          const prevNotesDiv = document.querySelector(`[data-page-num="${currentSpeakingPage}"]`);
          if (prevBtn) {
            prevBtn.classList.remove('speaking');
            prevBtn.innerHTML = 'üîä Speak';
          }
          if (prevNotesDiv) {
            clearHighlights(prevNotesDiv);
          }
        }
      }
      
      if (!noteText) {
        alert('No notes to read. Please add some notes first.');
        return;
      }
      
      // Check if speech synthesis is supported
      if (!('speechSynthesis' in window)) {
        alert('Text-to-speech is not supported in your browser.');
        return;
      }
      
      // Store original text
      originalText = noteText;
      
      // Split text into words for fallback highlighting
      const words = noteText.split(/\s+/);
      let currentWordIndex = 0;
      let boundarySupported = false;
      
      // Create and configure speech
      currentSpeech = new SpeechSynthesisUtterance(noteText);
      currentSpeakingPage = pageNum;
      
      // Configure speech properties with user-selected speed
      const speed = parseFloat(speedSlider.value);
      currentSpeech.rate = speed;
      currentSpeech.pitch = 1.0;
      currentSpeech.volume = 1.0;
      
      // Update button state
      speakBtn.classList.add('speaking');
      speakBtn.innerHTML = '‚è∏Ô∏è Stop';
      
      // Try to use boundary events (more accurate)
      currentSpeech.onboundary = (event) => {
        if (event.name === 'word' && event.charIndex !== undefined) {
          boundarySupported = true;
          // Clear the fallback interval once we know boundary events work
          if (highlightInterval) {
            clearInterval(highlightInterval);
            highlightInterval = null;
          }
          highlightTextAtPosition(notesDiv, event.charIndex, noteText);
        }
      };
      
      // Handle speech start - begin highlighting when speech actually starts
      currentSpeech.onstart = () => {
        // Fallback: timer-based highlighting (faster timing for better sync)
        const avgWordDuration = (60000 / (160 * speed)); // 160 WPM to match speech synthesis
        
        // Start highlighting with first word
        if (words.length > 0) {
          highlightWordByIndex(notesDiv, 0, words);
          currentWordIndex = 1;
        }
        
        highlightInterval = setInterval(() => {
          if (!boundarySupported && currentWordIndex < words.length) {
            highlightWordByIndex(notesDiv, currentWordIndex, words);
            currentWordIndex++;
          }
        }, avgWordDuration);
      };
      
      // Handle speech end
      currentSpeech.onend = () => {
        speakBtn.classList.remove('speaking');
        speakBtn.innerHTML = 'üîä Speak';
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
      };
      
      // Handle speech error
      currentSpeech.onerror = (event) => {
        console.error('Speech error:', event);
        speakBtn.classList.remove('speaking');
        speakBtn.innerHTML = 'üîä Speak';
        clearInterval(highlightInterval);
        clearHighlights(notesDiv);
        currentSpeech = null;
        currentSpeakingPage = null;
      };
      
      // Start speaking
      window.speechSynthesis.speak(currentSpeech);
    }
    
    function toggleParagraph(index) {
      const checkbox = document.getElementById('check-' + index);
      updateParagraphStyle(index);
    }
    
    function updateParagraphStyle(index) {
      const checkbox = document.getElementById('check-' + index);
      const btn = document.getElementById('para-btn-' + index);
      
      if (checkbox.checked) {
        btn.classList.add('selected');
      } else {
        btn.classList.remove('selected');
      }
    }
    
    function selectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = true;
          updateParagraphStyle(i);
        }
      }
    }
    
    function deselectAllInPage(pageNum, startIdx, endIdx) {
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox) {
          checkbox.checked = false;
          updateParagraphStyle(i);
        }
      }
    }
    
    function copySelectedInPage(startIdx, endIdx) {
      const selectedTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        const checkbox = document.getElementById('check-' + i);
        if (checkbox && checkbox.checked) {
          selectedTexts.push(allParagraphs[i]);
        }
      }
      
      if (selectedTexts.length === 0) {
        return;
      }
      
      const combinedText = selectedTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(() => {
        showCopyFeedback(event.target);
      });
    }
    
    function copyAllInPage(startIdx, endIdx, event) {
      const pageTexts = [];
      
      for (let i = startIdx; i < endIdx; i++) {
        pageTexts.push(allParagraphs[i]);
      }
      
      const combinedText = pageTexts.join('\n\n');
      navigator.clipboard.writeText(combinedText).then(() => {
        showCopyFeedback(event.target);
      });
    }
    
    function showCopyFeedback(button) {
      const originalText = button.textContent;
      const originalBg = button.style.background;
      button.textContent = '‚úì Copied!';
      button.style.background = '#4CAF50';
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = originalBg;
      }, 2000);
    }
    
    function copyParagraph(index) {
      const text = allParagraphs[index];
      navigator.clipboard.writeText(text).then(() => {
        const label = document.querySelector(`#para-btn-${index} label`);
        const originalText = label.textContent;
        label.textContent = '‚úì';
        setTimeout(() => {
          label.textContent = originalText;
        }, 1500);
      });
    }
    
    function copyAll() {
      const selectedTexts = [];
      
      // Check if any checkboxes are selected
      document.querySelectorAll('.para-checkbox:checked').forEach(checkbox => {
        const index = parseInt(checkbox.dataset.index);
        selectedTexts.push(allParagraphs[index]);
      });
      
      // If nothing selected, copy all
      const textToCopy = selectedTexts.length > 0 ? selectedTexts.join('\n\n') : allParagraphs.join('\n\n');
      const count = selectedTexts.length > 0 ? selectedTexts.length : allParagraphs.length;
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        const btn = copyAllBtn;
        const originalText = btn.textContent;
        btn.textContent = `‚úì Copied ${count}!`;
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      });
    }
    
    function resetApp() {
      uploadSection.style.display = 'block';
      results.classList.remove('show');
      copyAllBtn.style.display = 'none';
      fileInput.value = '';
      allParagraphs = [];
    }
    
    // Theme toggle functionality
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      const themeToggle = document.getElementById('themeToggle');
      
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      // Update button icon
      themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Load saved theme on page load
    function loadTheme() {
      const savedTheme = localStorage.getItem('theme') || 'light';
      const html = document.documentElement;
      const themeToggle = document.getElementById('themeToggle');
      
      html.setAttribute('data-theme', savedTheme);
      if (themeToggle) {
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
    }
    
    // Initialize theme on load
    loadTheme();
  </script>
</body>
</html>
